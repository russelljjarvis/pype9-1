

/* This file was generated by PyPe9 version 0.1 on Sat 16 Apr 16 11:46:19PM */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "IafAlpha.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"

/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::IafAlpha> nineml::IafAlpha::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::IafAlpha>::create() {
    insert_("end_refractory__cell", &nineml::IafAlpha::get_y_elem_<nineml::IafAlpha::State_::end_refractory__cell_INDEX>);
    insert_("v__cell", &nineml::IafAlpha::get_y_elem_<nineml::IafAlpha::State_::v__cell_INDEX>);
    insert_("a__psr__syn", &nineml::IafAlpha::get_y_elem_<nineml::IafAlpha::State_::a__psr__syn_INDEX>);
    insert_("b__psr__syn", &nineml::IafAlpha::get_y_elem_<nineml::IafAlpha::State_::b__psr__syn_INDEX>);
  }
}

/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

std::string ExceededMaximumSimultaneousTransitions::message() {
    std::ostringstream msg;
    msg << "Exceeded maxium number of simultaneous transitions (" << num_transitions << ")";
    msg << " in " << model << " at " << t << " ms. Probable infinite loop.";
    return msg.str();
}


IafAlpha::Regime_::~Regime_() {
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        delete *it;
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)    
        delete *it;
}

IafAlpha::Transition_* IafAlpha::Regime_::transition(nest::Time const& origin, const nest::long_t& lag) {
    // Set the time to the end of the current timestep
    double t = origin.get_ms() + lag * nest::Time::get_resolution().get_ms();

    // Get vector of transitions (both OnConditions and OnEvents) that are triggered in the current timestep
    std::vector<Transition_*> occurred;
    for (std::vector<OnCondition_*>::iterator it = active_on_conditions.begin(); it != active_on_conditions.end(); ++it)
        if ((*it)->condition(t))
            occurred.push_back(*it);
            
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)
        if ((*it)->received(origin, lag))
            occurred.push_back(*it);

    // Get the earliest transition to be triggered
    Transition_* transition;
    if (!occurred.size())
        transition = NULL;
    else if (occurred.size() == 1)
        transition = occurred[0];
    else {
        std::vector<double> times;
        for (std::vector<Transition_*>::iterator it = occurred.begin(); it != occurred.end(); ++it) 
            times.push_back((*it)->time_occurred(origin, lag));
        int min_index = std::min_element(times.begin(), times.end()) - times.begin();
        transition = occurred[min_index];
    }
    return transition;
}


void IafAlpha::Regime_::set_triggers(double t) {
    // Reset the vector of active transitions
    active_on_conditions.clear();
    
    // Add OnConditions to the list of active transitions if their trigger condition evaluates to false
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        if (!(*it)->condition(t))
            active_on_conditions.push_back(*it);
        
}



/**
 *  Dynamics and transitions for refractory___sole_____sole regime
 */

extern "C" int IafAlpha_refractory___sole_____sole_dynamics(double t, const double y_[], double f_[], void* pnode_) {

    // Get references to the members of the model
    assert(pnode_);
    const IafAlpha& node_ = *(reinterpret_cast<IafAlpha*>(pnode_));
    const IafAlpha::Parameters_& P_ = node_.P_;
    const IafAlpha::State_& S_ = node_.S_;
    const IafAlpha::Buffers_& B_ = node_.B_;

    // State Variables
    const double_t& b__psr__syn = S_.y_[IafAlpha::State_::b__psr__syn_INDEX];  // (pA)
    const double_t& a__psr__syn = S_.y_[IafAlpha::State_::a__psr__syn_INDEX];  // (pA)
        
    
    // Parameters
    const double_t& tau__psr__syn = P_.tau__psr__syn;  // (ms)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    // Evaluate differential equations
    ITEM(f_, IafAlpha::State_::a__psr__syn_INDEX) = (-a__psr__syn + b__psr__syn)/tau__psr__syn;  // (pA/ms)
    ITEM(f_, IafAlpha::State_::b__psr__syn_INDEX) = -b__psr__syn/tau__psr__syn;  // (pA/ms)
	
    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
    return GSL_SUCCESS;}        
    
/* Jacobian for the refractory___sole_____sole regime if required by the solver */
/** Diagonal Jacobian approximation (for GSL): (f(s+.01) - f(s))/.001 */
extern "C" int IafAlpha_refractory___sole_____sole_jacobian(double t, const double y[], double *dfdy, double dfdt[], void* node) {
    // cast the node ptr to IafAlpha object
    assert(node);
    IafAlpha& cell =    *(reinterpret_cast<IafAlpha*>(node));
    IafAlpha::refractory___sole_____soleRegime_& regime = *(reinterpret_cast<IafAlpha::refractory___sole_____soleRegime_*>(cell.get_regime("refractory___sole_____sole")));

    for (unsigned int i = 0; i < regime.N; i++)
        regime.u[i] = y[i] + 0.01;

    IafAlpha_refractory___sole_____sole_dynamics(t, regime.u, regime.jac, node);
    for (unsigned int i = 0; i < regime.N; i++)
        dfdt[i*regime.N + i] = (regime.jac[i] - dfdy[i]) / .001;
    return 0;
}
IafAlpha::refractory___sole_____soleRegime_::refractory___sole_____soleRegime_(IafAlpha* cell)
  : Regime_(cell, IafAlpha_refractory___sole_____sole_dynamics),
      IntegrationStep_(0),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0) {
  
    // Construct OnConditions specific to the regime.
    on_conditions.push_back(new refractory___sole_____soleOnCondition0(this, "subthreshold___sole_____sole"));
	
    // Construct OnConditions specific to the regime.
    on_events.push_back(new refractory___sole_____soleOninput_spikeEvent(this, "refractory___sole_____sole"));              

}

IafAlpha::refractory___sole_____soleRegime_::~refractory___sole_____soleRegime_() {
    
    // GSL structs only allocated by init_nodes_(),
    // so we need to protect destruction
    if ( s_ != NULL)
        gsl_odeiv2_step_free (s_);
    if ( c_ != NULL)
        gsl_odeiv2_control_free (c_);
    if ( e_ != NULL)
        gsl_odeiv2_evolve_free (e_);
    if ( u != NULL)
        free (u);
    if ( jac != NULL)
        free (jac);}

void IafAlpha::refractory___sole_____soleRegime_::init_solver() {
    

    IntegrationStep_ = cell->B_.step_;

    static const gsl_odeiv2_step_type* T1 = gsl_odeiv2_step_rk2;
    //FIXME: Could be reduced to include only the states which have a time
    //       derivative
    N = 4;

    if ( s_ == 0 )
        s_ = gsl_odeiv2_step_alloc (T1, N);
    else
        gsl_odeiv2_step_reset(s_);

    if ( c_ == 0 )
        c_ = gsl_odeiv2_control_standard_new (0.001, 0.0, 1.0, 0.0);
    else
        gsl_odeiv2_control_init(c_, 0.001, 0.0, 1.0, 0.0);

    if ( e_ == 0 )
        e_ = gsl_odeiv2_evolve_alloc(N);
    else
        gsl_odeiv2_evolve_reset(e_);

    sys_.function  = IafAlpha_refractory___sole_____sole_dynamics;
    sys_.jacobian  = IafAlpha_refractory___sole_____sole_jacobian;
    sys_.dimension = N;
    sys_.params    = reinterpret_cast<void*>(this->cell);

    if (u == 0)
        u = (double *)malloc(sizeof(double) * N);
        assert (u);
    if (jac == 0)
        jac = (double *)malloc(sizeof(double) * N);
        assert (jac);    
}

void IafAlpha::refractory___sole_____soleRegime_::step_ode() {
    IafAlpha::State_& S_ = cell->S_;
    //FIXME: Clamping of vars should be replaced by the resizing of the state
    //       vector that is solved to only the states that have time-derivatives
    //       in the regime.
    /***** Set clamp vars for state variables that don't have a time derivative in this regime *****/
    double end_refractory__cell_clamp_ = S_.y_[IafAlpha::State_::end_refractory__cell_INDEX];
    double v__cell_clamp_ = S_.y_[IafAlpha::State_::v__cell_INDEX];

    // Step ODE solver
    double dt = nest::Time::get_resolution().get_ms();
    double tt = 0.0;
    while (tt < dt) {
        const int status =  gsl_odeiv2_evolve_apply(
            e_, c_, s_,
            &sys_, // system of ODE
            &tt, // from t...
            dt, // ...to t= t + dt
            &IntegrationStep_, // integration window (written on!)
            cell->S_.y_); // neuron state
        if (status != GSL_SUCCESS)
          throw nest::GSLSolverFailure(cell->get_name(), status);
    }    
    /***** Reset state variables from clamp vars for state variables that don't have a time derivative in this regime *****/
    S_.y_[IafAlpha::State_::end_refractory__cell_INDEX] = end_refractory__cell_clamp_;
    S_.y_[IafAlpha::State_::v__cell_INDEX] = v__cell_clamp_;
}

// Transition methods for refractory___sole_____sole regime


bool IafAlpha::refractory___sole_____soleOninput_spikeEvent::body(double t) {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
    // Decrement the number of remaining events
    assert(B_.num_unprocessed_input_spike_events);
    --B_.num_unprocessed_input_spike_events;
    
    // State Variables
    const double_t& b__psr__syn = S_.y_[IafAlpha::State_::b__psr__syn_INDEX];  // (pA)
        
    
    // Parameters
    const double_t& weight__pls__syn = P_.weight__pls__syn;  // (pA)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    const double_t fixed_weight__pls__syn = weight__pls__syn;  // (pA)
    const double_t q__psr__syn = fixed_weight__pls__syn;  // (pA)
    

    // State assignments
    S_.y_[IafAlpha::State_::b__psr__syn_INDEX] = b__psr__syn + q__psr__syn;  // (pA)
	        
    // Output events
        
    return true;  // Transition contains discontinuous changes in state
}


bool IafAlpha::refractory___sole_____soleOnCondition0::body(double t) {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
    
    // State Variables
        
    
    // Parameters
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    // State assignments
	        
    // Output events
        
    return false;  // Transition doesn't contain discontinuous changes in state
}

    
double IafAlpha::refractory___sole_____soleOninput_spikeEvent::OnEvent_::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
    //FIXME: Should use the exact spike time specified in the spike event
    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
}


bool IafAlpha::OnEvent_::refractory___sole_____soleOninput_spikeEvent::received(nest::Time const& origin, const nest::long_t& lag) {
    return (bool)regime->cell->B_.num_unprocessed_input_spike_events;
}

bool IafAlpha::refractory___sole_____soleOnCondition0::condition(double t) {
	    
    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
        
    // State Variables
    const double_t& end_refractory__cell = S_.y_[IafAlpha::State_::end_refractory__cell_INDEX];  // (ms)
        
    
    // Parameters
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    return t > end_refractory__cell;

}

double IafAlpha::refractory___sole_____soleOnCondition0::time_occurred(nest::Time const& origin, const nest::long_t& lag) {

    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
       
    // State Variables
    const double_t& end_refractory__cell = S_.y_[IafAlpha::State_::end_refractory__cell_INDEX];  // (ms)
        
    
    // Parameters
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
           
    // The trigger expression depends on 't' so determine the exact time that the threshold was crossed.
    return end_refractory__cell;
}


/**
 *  Dynamics and transitions for subthreshold___sole_____sole regime
 */

extern "C" int IafAlpha_subthreshold___sole_____sole_dynamics(double t, const double y_[], double f_[], void* pnode_) {

    // Get references to the members of the model
    assert(pnode_);
    const IafAlpha& node_ = *(reinterpret_cast<IafAlpha*>(pnode_));
    const IafAlpha::Parameters_& P_ = node_.P_;
    const IafAlpha::State_& S_ = node_.S_;
    const IafAlpha::Buffers_& B_ = node_.B_;

    // State Variables
    const double_t& v__cell = S_.y_[IafAlpha::State_::v__cell_INDEX];  // (mV)
    const double_t& a__psr__syn = S_.y_[IafAlpha::State_::a__psr__syn_INDEX];  // (pA)
    const double_t& b__psr__syn = S_.y_[IafAlpha::State_::b__psr__syn_INDEX];  // (pA)
        
    
    // Parameters
    const double_t& g_leak__cell = P_.g_leak__cell;  // (nS)
    const double_t& Cm__cell = P_.Cm__cell;  // (pF)
    const double_t& tau__psr__syn = P_.tau__psr__syn;  // (ms)
    const double_t& e_leak__cell = P_.e_leak__cell;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    const double_t i_synaptic__psr__syn = a__psr__syn;  // (pA)
    const double_t i_synaptic__cell = i_synaptic__psr__syn;  // (pA)
    

    // Evaluate differential equations
    ITEM(f_, IafAlpha::State_::v__cell_INDEX) = (g_leak__cell*(e_leak__cell - v__cell) + i_synaptic__cell)/Cm__cell;  // (mV/ms)
    ITEM(f_, IafAlpha::State_::a__psr__syn_INDEX) = (-a__psr__syn + b__psr__syn)/tau__psr__syn;  // (pA/ms)
    ITEM(f_, IafAlpha::State_::b__psr__syn_INDEX) = -b__psr__syn/tau__psr__syn;  // (pA/ms)
	
    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
    return GSL_SUCCESS;}        
    
/* Jacobian for the subthreshold___sole_____sole regime if required by the solver */
/** Diagonal Jacobian approximation (for GSL): (f(s+.01) - f(s))/.001 */
extern "C" int IafAlpha_subthreshold___sole_____sole_jacobian(double t, const double y[], double *dfdy, double dfdt[], void* node) {
    // cast the node ptr to IafAlpha object
    assert(node);
    IafAlpha& cell =    *(reinterpret_cast<IafAlpha*>(node));
    IafAlpha::subthreshold___sole_____soleRegime_& regime = *(reinterpret_cast<IafAlpha::subthreshold___sole_____soleRegime_*>(cell.get_regime("subthreshold___sole_____sole")));

    for (unsigned int i = 0; i < regime.N; i++)
        regime.u[i] = y[i] + 0.01;

    IafAlpha_subthreshold___sole_____sole_dynamics(t, regime.u, regime.jac, node);
    for (unsigned int i = 0; i < regime.N; i++)
        dfdt[i*regime.N + i] = (regime.jac[i] - dfdy[i]) / .001;
    return 0;
}
IafAlpha::subthreshold___sole_____soleRegime_::subthreshold___sole_____soleRegime_(IafAlpha* cell)
  : Regime_(cell, IafAlpha_subthreshold___sole_____sole_dynamics),
      IntegrationStep_(0),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0) {
  
    // Construct OnConditions specific to the regime.
    on_conditions.push_back(new subthreshold___sole_____soleOnCondition0(this, "refractory___sole_____sole"));
	
    // Construct OnConditions specific to the regime.
    on_events.push_back(new subthreshold___sole_____soleOninput_spikeEvent(this, "subthreshold___sole_____sole"));              

}

IafAlpha::subthreshold___sole_____soleRegime_::~subthreshold___sole_____soleRegime_() {
    
    // GSL structs only allocated by init_nodes_(),
    // so we need to protect destruction
    if ( s_ != NULL)
        gsl_odeiv2_step_free (s_);
    if ( c_ != NULL)
        gsl_odeiv2_control_free (c_);
    if ( e_ != NULL)
        gsl_odeiv2_evolve_free (e_);
    if ( u != NULL)
        free (u);
    if ( jac != NULL)
        free (jac);}

void IafAlpha::subthreshold___sole_____soleRegime_::init_solver() {
    

    IntegrationStep_ = cell->B_.step_;

    static const gsl_odeiv2_step_type* T1 = gsl_odeiv2_step_rk2;
    //FIXME: Could be reduced to include only the states which have a time
    //       derivative
    N = 4;

    if ( s_ == 0 )
        s_ = gsl_odeiv2_step_alloc (T1, N);
    else
        gsl_odeiv2_step_reset(s_);

    if ( c_ == 0 )
        c_ = gsl_odeiv2_control_standard_new (0.001, 0.0, 1.0, 0.0);
    else
        gsl_odeiv2_control_init(c_, 0.001, 0.0, 1.0, 0.0);

    if ( e_ == 0 )
        e_ = gsl_odeiv2_evolve_alloc(N);
    else
        gsl_odeiv2_evolve_reset(e_);

    sys_.function  = IafAlpha_subthreshold___sole_____sole_dynamics;
    sys_.jacobian  = IafAlpha_subthreshold___sole_____sole_jacobian;
    sys_.dimension = N;
    sys_.params    = reinterpret_cast<void*>(this->cell);

    if (u == 0)
        u = (double *)malloc(sizeof(double) * N);
        assert (u);
    if (jac == 0)
        jac = (double *)malloc(sizeof(double) * N);
        assert (jac);    
}

void IafAlpha::subthreshold___sole_____soleRegime_::step_ode() {
    IafAlpha::State_& S_ = cell->S_;
    //FIXME: Clamping of vars should be replaced by the resizing of the state
    //       vector that is solved to only the states that have time-derivatives
    //       in the regime.
    /***** Set clamp vars for state variables that don't have a time derivative in this regime *****/
    double end_refractory__cell_clamp_ = S_.y_[IafAlpha::State_::end_refractory__cell_INDEX];

    // Step ODE solver
    double dt = nest::Time::get_resolution().get_ms();
    double tt = 0.0;
    while (tt < dt) {
        const int status =  gsl_odeiv2_evolve_apply(
            e_, c_, s_,
            &sys_, // system of ODE
            &tt, // from t...
            dt, // ...to t= t + dt
            &IntegrationStep_, // integration window (written on!)
            cell->S_.y_); // neuron state
        if (status != GSL_SUCCESS)
          throw nest::GSLSolverFailure(cell->get_name(), status);
    }    
    /***** Reset state variables from clamp vars for state variables that don't have a time derivative in this regime *****/
    S_.y_[IafAlpha::State_::end_refractory__cell_INDEX] = end_refractory__cell_clamp_;
}

// Transition methods for subthreshold___sole_____sole regime


bool IafAlpha::subthreshold___sole_____soleOninput_spikeEvent::body(double t) {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
    // Decrement the number of remaining events
    assert(B_.num_unprocessed_input_spike_events);
    --B_.num_unprocessed_input_spike_events;
    
    // State Variables
    const double_t& b__psr__syn = S_.y_[IafAlpha::State_::b__psr__syn_INDEX];  // (pA)
        
    
    // Parameters
    const double_t& weight__pls__syn = P_.weight__pls__syn;  // (pA)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    const double_t fixed_weight__pls__syn = weight__pls__syn;  // (pA)
    const double_t q__psr__syn = fixed_weight__pls__syn;  // (pA)
    

    // State assignments
    S_.y_[IafAlpha::State_::b__psr__syn_INDEX] = b__psr__syn + q__psr__syn;  // (pA)
	        
    // Output events
        
    return true;  // Transition contains discontinuous changes in state
}


bool IafAlpha::subthreshold___sole_____soleOnCondition0::body(double t) {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
    
    // State Variables
        
    
    // Parameters
    const double_t& refractory_period__cell = P_.refractory_period__cell;  // (ms)
    const double_t& v_reset__cell = P_.v_reset__cell;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    // State assignments
    S_.y_[IafAlpha::State_::end_refractory__cell_INDEX] = refractory_period__cell + t;  // (ms)
    S_.y_[IafAlpha::State_::v__cell_INDEX] = v_reset__cell;  // (mV)
	        
    // Output events
        
    return true;  // Transition contains discontinuous changes in state
}

    
double IafAlpha::subthreshold___sole_____soleOninput_spikeEvent::OnEvent_::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
    //FIXME: Should use the exact spike time specified in the spike event
    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
}


bool IafAlpha::OnEvent_::subthreshold___sole_____soleOninput_spikeEvent::received(nest::Time const& origin, const nest::long_t& lag) {
    return (bool)regime->cell->B_.num_unprocessed_input_spike_events;
}

bool IafAlpha::subthreshold___sole_____soleOnCondition0::condition(double t) {
	    
    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
        
    // State Variables
    const double_t& v__cell = S_.y_[IafAlpha::State_::v__cell_INDEX];  // (mV)
        
    
    // Parameters
    const double_t& v_threshold__cell = P_.v_threshold__cell;  // (mV)
    
    // Analog receive ports
    
    // Constants
    
    // Random variables
    
    // Aliases
    

    return v__cell > v_threshold__cell;

}

double IafAlpha::subthreshold___sole_____soleOnCondition0::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
}



/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/


/***********************
 * Steady-sate solvers *
 ***********************/




/****************
 * Constructors *
 ****************/

IafAlpha::IafAlpha()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {

    recordablesMap_.create();
    construct_regimes();
        
}

IafAlpha::IafAlpha(const IafAlpha& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {
      
    construct_regimes();
}

/**
 * Constructs all regimes (and their transitions) in the component class
 */      
void IafAlpha::construct_regimes() {

    // Construct all regimes
    regimes["refractory___sole_____sole"] = new refractory___sole_____soleRegime_(this);
    regimes["subthreshold___sole_____sole"] = new subthreshold___sole_____soleRegime_(this);

    // Set target regimes in all transitions
    Regime_* regime;

    regime = get_regime("refractory___sole_____sole");
    for (std::vector<OnEvent_*>::iterator it = regime->on_events.begin(); it != regime->on_events.end(); ++it)
        (*it)->set_target_regime(regimes);
    for (std::vector<OnCondition_*>::iterator it = regime->on_conditions.begin(); it != regime->on_conditions.end(); ++it)
        (*it)->set_target_regime(regimes);   
    regime = get_regime("subthreshold___sole_____sole");
    for (std::vector<OnEvent_*>::iterator it = regime->on_events.begin(); it != regime->on_events.end(); ++it)
        (*it)->set_target_regime(regimes);
    for (std::vector<OnCondition_*>::iterator it = regime->on_conditions.begin(); it != regime->on_conditions.end(); ++it)
        (*it)->set_target_regime(regimes);   
}

void IafAlpha::init_node_(const Node& proto) {
    const IafAlpha& pr = downcast<IafAlpha>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void IafAlpha::init_state_(const Node& proto) {
    const IafAlpha& pr = downcast<IafAlpha>(proto);
    S_ = State_(pr.P_);
}

/**************
 * Destructor *
 **************/

IafAlpha::~IafAlpha () {
    // Destruct all regimes
    for (std::map<std::string, Regime_*>::iterator it = regimes.begin(); it != regimes.end(); ++it)
        delete it->second;
    regimes.clear();
}


/**********************************
 * Define parameters of the model *
 **********************************/

IafAlpha::Parameters_::Parameters_():
    g_leak__cell (0.0),
    Cm__cell (0.0),
    refractory_period__cell (0.0),
    v_threshold__cell (0.0),
    v_reset__cell (0.0),
    e_leak__cell (0.0),
    tau__psr__syn (0.0) {
// Check constraints on parameters
}

/************************************
 * Construct state from parameters.
 ************************************/

IafAlpha::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
    y_[end_refractory__cell_INDEX] = 0.0;
    y_[v__cell_INDEX] = 0.0;
    y_[a__psr__syn_INDEX] = 0.0;
    y_[b__psr__syn_INDEX] = 0.0;

}

/***********************************
 * Copy constructor for State class
 ***********************************/
IafAlpha::State_::State_(const State_& s) {
  for (int i = 0 ; i < 4 ; ++i)
      y_[i] = s.y_[i];
}

/********************************************
 * Assignment of a State from another State *
 ********************************************/

IafAlpha::State_& IafAlpha::State_::operator=(const State_& s) {
  assert(this != &s);
  for (size_t i = 0 ; i < 4 ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void IafAlpha::calibrate() {
    B_.logger_.init();
    V_.rng_ = net_->get_rng( get_thread() );
}

/***************************
 * Accessors and Modifiers *
 ***************************/

void IafAlpha::Parameters_::get (DictionaryDatum &d_) const {

    // Update dictionary from internal parameters, scaling if required.
    def<double_t>(d_, "g_leak__cell", g_leak__cell);
    def<double_t>(d_, "Cm__cell", Cm__cell);
    def<double_t>(d_, "refractory_period__cell", refractory_period__cell);
    def<double_t>(d_, "v_threshold__cell", v_threshold__cell);
    def<double_t>(d_, "v_reset__cell", v_reset__cell);
    def<double_t>(d_, "e_leak__cell", e_leak__cell);
    def<double_t>(d_, "tau__psr__syn", tau__psr__syn);

}

void IafAlpha::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
    updateValue<double_t>(d_, "g_leak__cell", g_leak__cell);
    updateValue<double_t>(d_, "Cm__cell", Cm__cell);
    updateValue<double_t>(d_, "refractory_period__cell", refractory_period__cell);
    updateValue<double_t>(d_, "v_threshold__cell", v_threshold__cell);
    updateValue<double_t>(d_, "v_reset__cell", v_reset__cell);
    updateValue<double_t>(d_, "e_leak__cell", e_leak__cell);
    updateValue<double_t>(d_, "tau__psr__syn", tau__psr__syn);

    // Scale parameters as required
}

void IafAlpha::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
    def<double_t>(d_, "end_refractory__cell", y_[0]);
    def<double_t>(d_, "v__cell", y_[1]);
    def<double_t>(d_, "a__psr__syn", y_[2]);
    def<double_t>(d_, "b__psr__syn", y_[3]);
}

void IafAlpha::State_::set (const DictionaryDatum &d_, const Parameters_&) {
    // Set internal state variables from dictionary values
    updateValue<double_t>(d_, "end_refractory__cell", y_[0]);
    updateValue<double_t>(d_, "v__cell", y_[1]);
    updateValue<double_t>(d_, "a__psr__syn", y_[2]);
    updateValue<double_t>(d_, "b__psr__syn", y_[3]);
}

/***********
 * Buffers *
 ***********/

IafAlpha::Buffers_::Buffers_(IafAlpha& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

IafAlpha::Buffers_::Buffers_(const Buffers_&, IafAlpha& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void IafAlpha::init_buffers_() {

    // Clear event buffers
    B_.input_spike_event_port.clear();

    // Clear analog buffers

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();


    B_.current_regime = get_regime("refractory___sole_____sole");
    B_.current_regime->set_triggers(0);
    B_.current_regime->init_solver();

}


void IafAlpha::refresh_events(const nest::long_t& lag) {
    B_.num_unprocessed_input_spike_events = B_.input_spike_event_port.get_value(lag);
}

/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/


/***********************
 * Evaluate the update *
 ***********************/

void IafAlpha::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    nest::long_t current_steps = origin.get_steps();

    for (nest::long_t lag = from; lag < to; ++lag) {

        /***** Solve ODE over timestep *****/
        B_.current_regime->step_ode();

        /***** Transition handling *****/
        // Get multiplicity incoming events for the current lag and reset multiplicity of outgoing events
        refresh_events(lag);
        
        Transition_* transition;
        int simultaneous_transition_count = 0;
        double prev_t = origin.get_ms();
        while ((transition = B_.current_regime->transition(origin, lag))) {  // Check for a transition (i.e. the output of current_regime->transition is not NULL) and record it in the 'transition' variable.
            double t = transition->time_occurred(origin, lag);  // Get the exact time the transition occurred.
            if (t == prev_t) {
                ++simultaneous_transition_count;
                if (simultaneous_transition_count > MAX_SIMULTANEOUS_TRANSITIONS)
                    throw ExceededMaximumSimultaneousTransitions("IafAlpha", simultaneous_transition_count, t);
            } else
                simultaneous_transition_count = 0;
            // Execute body of transition, flagging a discontinuity in the ODE system
            // if either the body contains state assignments (i.e. not just output
            // events) or the regime changes
            bool discontinuous = transition->body(t) || (transition->get_target_regime() != B_.current_regime);
            // Update the current regime
            B_.current_regime = transition->get_target_regime();
            // Set all triggers, i.e. activate all triggers for which their trigger condition 
            // evaluates to false.
            B_.current_regime->set_triggers(t);
            // Reinitialise the solve if the is a discontinuity in the ODE system
            if (discontinuous)
                B_.current_regime->init_solver();  // Reset the solver if the transition contains state assignments or switches to a new regime.
        }
        
        /***** Send output events for each event send port *****/
        // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
        // Output events        

        /***** Get analog port values *****/

        /***** Record data *****/
        B_.logger_.record_data(current_steps + lag);
    }
}

/*****************
 * Event Handles *
 *****************/

void IafAlpha::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
    if (e.get_rport() == input_spike_EVENT_PORT) {
        B_.input_spike_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
    }
}

void IafAlpha::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
}

void IafAlpha::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace