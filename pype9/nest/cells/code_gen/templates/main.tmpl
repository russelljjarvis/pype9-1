{% import "macros.tmpl" as macros %}

{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}
{% set debug = False %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"

/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in component_class.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
  }
}

/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

	extern "C" int {{component_name}}_dynamics{% include "dynamics_signature.tmpl" %} {
	
		// Get references to the members of the model
		assert(pnode_);
		const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));
		const {{component_name}}::Parameters_& P_ = node_.P_;
		const {{component_name}}::State_& S_ = node_.S_;
		const {{component_name}}::Buffers_& B_ = node_.B_;
	
{% for regime in component_class.regimes %}
	    {{elseif(loop.first)}} (B_.current_regime == {{component_name}}::{{regime.name}}_REGIME) {
		    {{macros.map_required_vars_locally(regime.time_derivatives, component_class, component_name, unit_handler, []) | indent(8)}}
		    // Evaluate differential equations
	{% for td, scaled_expr, units in unit_handler.scale_time_derivatives(regime.time_derivatives) %}
		    //std::cout << "{{td.dependent_variable}}=" << {{scaled_expr.rhs_cstr}};
		    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{scaled_expr.rhs_cstr}};  // ({{units}})
	{% endfor %}
	    {{endif(loop.last)}}
{% endfor %}
	
	    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
	    {% include "dynamics_return.tmpl" %}
	
	}


	{{component_name}}::Transition_* {{component_name}}::Regime_::transition(nest::Time const& origin, const nest::long_t& lag) {
	    // Get vector of transitions (both OnConditions and OnEvents) that are triggered in the current timestep
	    std::vector<Transition_*> occurred;
	    for (std::vector<OnCondition_*>::iterator it = this->active_on_conditions.begin(); it != this->active_on_conditions.end(); ++it)
	        if ((*it)->condition(origin, lag))
	            occurred.push_back(*it);
	            
	    for (std::vector<OnEvent_*>::iterator it = this->on_events.begin(); it != this->on_events.end(); ++it)
	        if ((*it)->received(origin, lag))
	            occurred.push_back(*it);
	
	    // Get the earliest transition to be triggered
	    Transition_* transition;
	    if (!occurred.size())
	        transition = NULL;
	    else if (occurred.size() == 1)
	        transition = occurred[0];
	    else {
	        std::vector<double> times;
	        for (std::vector<Transition_*>::iterator it = occurred.begin(); it != occurred.end(); ++it) 
	            times.push_back((*it)->time_occurred(origin, lag));
	        int min_index = std::min_element(times.begin(), times.end()) - times.begin();
	        transition = occurred[min_index];
	    }
	    return transition;
	}


	void {{component_name}}::Regime_::set_triggers(nest::Time const& origin, const nest::long_t& lag) {
	    // Reset the vector of active transitions
	    this->active_on_conditions.clear();
	    
	    // Add OnConditions to the list of active transitions if their trigger condition evaluates to false
	    for (std::vector<OnCondition_*>::iterator it = this->on_conditions.begin(); it != this->on_conditions.end(); ++it)
	        if (!(*it)->condition(origin, lag))
	            this->active_on_conditions.push_back(*it);
	        
	}

{% for regime in component_class.regimes %}

	/**
	 *  Dynamics and transitions for {{regime.name}} regime
	 */

    {% if regime.num_time_derivatives %}
	extern "C" int {{component_name}}_{{regime.name}}_dynamics{% include "dynamics_signature.tmpl" %} {
	
	    // Get references to the members of the model
	    assert(pnode_);
	    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));
	    const {{component_name}}::Parameters_& P_ = node_.P_;
	    const {{component_name}}::State_& S_ = node_.S_;
	    const {{component_name}}::Buffers_& B_ = node_.B_;
	
	    {{macros.map_required_vars_locally(regime.time_derivatives, component_class, component_name, unit_handler, []) | indent(8)}}
	
	    // Evaluate differential equations
        {% for td, scaled_expr, units in unit_handler.scale_time_derivatives(regime.time_derivatives) %}
	    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}
	
	    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
        {% include "dynamics_return.tmpl" %}
    }        
    {% endif %}

	{{component_name}}::{{regime.name}}Regime::{{regime.name}}Regime({{component_name}}* cell)
	  : Regime_(cell{% if regime.num_time_derivatives %}, {{component_name}}_{{regime.name}}_dynamics{% endif %}) {
	  
	    // Construct OnConditions specific to the regime.
    {% for on_condition in regime.on_conditions %}
	    this->on_conditions.push_back(new {{regime.name}}OnCondition{{regime.index_of(on_condition)}}(this));
    {% endfor %}
	
	    // Construct OnConditions specific to the regime.
    {% for on_event in regime.on_events %}
	    this->on_events.push_back(new {{regime.name}}On{{on_event.src_port_name}}Event(this, this->cell->B_.{{on_event.src_port_name}}_event_port));              
    {% endfor %}
	}

	{{component_name}}::{{regime.name}}Regime::~{{regime.name}}Regime() {
	    for (std::vector<OnCondition_*>::iterator it = this->on_conditions.begin(); it != this->on_conditions.end(); ++it)
	        delete *it;
	    for (std::vector<OnEvent_*>::iterator it = this->on_events.begin(); it != this->on_events.end(); ++it)
	        delete *it;        
	}

    // Transition methods for {{regime.name}} regime

    {% for transition in regime.transitions %}
        {% if transition.nineml_type == 'OnCondition' %}
            {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(transition)) %}
        {% else %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, transition.src_port_name) %}
        {% endif %}

	void {{component_name}}::{{TransitionClassName}}::body(nest::Time const& origin, const nest::long_t& lag) {
	    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers
	
	
	    State_& S_ = this->regime->cell->S_;
	    const Buffers_& B_ = this->regime->cell->B_;
	    const Parameters_& P_ = this->regime->cell->P_;
	    Variables_& V_ = this->regime->cell->V_;
	    
	    {{macros.map_required_vars_locally(transition.state_assignments, component_class, component_name, unit_handler, []) | indent(8)}}
	
	    // State assignments
        {% for sa, scaled_expr, units in unit_handler.scale_aliases(transition.state_assignments) %}
	    S_.y_[{{component_name}}::State_::{{sa.name}}_INDEX] = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}
	        
	    // Output events 
	
	    // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
	    // Output events
        {% for output_event in transition.output_events %}
	    this->regime->cell->set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
	    nest::SpikeEvent se;
	    this->regime->cell->network()->send(*this->regime->cell, se, lag);
        {% endfor %}
	}

    {% endfor %}
    {% for on_event in regime.on_events %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, transition.src_port_name) %}
    
    double {{component_name}}::{{TransitionClassName}}::OnEvent_::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
        //FIXME: Should use the exact spike time specified in the spike event
        return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
    }
    
    
    bool {{component_name}}::OnEvent_::{{TransitionClassName}}::received(nest::Time const& origin, const nest::long_t& lag) {
        return (bool)this->regime->cell->B_.num_unprocessed_{{on_event.src_port_name}}_events;
    }

    {% endfor %}
    {% for on_condition in regime.on_conditions %}
        {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(on_condition)) %}
	bool {{component_name}}::{{TransitionClassName}}::condition(nest::Time const& origin, const nest::long_t& lag) {
	    
	    const State_& S_ = this->regime->cell->S_;
	    const Buffers_& B_ = this->regime->cell->B_;
	    const Parameters_& P_ = this->regime->cell->P_;
	    double t = origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
	        
	    {{macros.map_required_vars_locally(on_condition.trigger, component_class, component_name, unit_handler, []) | indent(8)}}
	
	    return {{on_condition.trigger.rhs_cstr}};
	
	}
	
	double {{component_name}}::{{TransitionClassName}}::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
       {% set exact_time_expr = on_condition.trigger.crossing_time_expr %}
       {% if exact_time_expr %}
	
	    const State_& S_ = this->regime->cell->S_;
	    const Buffers_& B_ = this->regime->cell->B_;
	    const Parameters_& P_ = this->regime->cell->P_;
	       
	    {{macros.map_required_vars_locally(exact_time_expr, component_class, component_name, unit_handler, []) | indent(8)}}       
	    // The trigger expression depends on 't' so determine the exact time that the threshold was crossed.
	    return {{exact_time_expr.rhs_cstr}};
       {% else %}
	    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
       {% endif %}
	}

	{% endfor %}
{% endfor %}


/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/

{% include "residual.tmpl" %}

/***********************
 * Steady-sate solvers *
 ***********************/

{% include "fsolve.tmpl" %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}

/***********************************************
 * Diagonal Jacobian approximation if required *
 ***********************************************/

{% include "jacobian.tmpl" %}

/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_():
{% for i, param in enumerate(component_class.parameters) %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{% for param in component_class.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
}

/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
{% for sv in component_class.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{% include "solve_steady_state.tmpl" %}
}

/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {
  for (int i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}

/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {
  assert(this != &s);
  for (size_t i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
    V_.rng_ = net_->get_rng( get_thread() );
}

/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in component_class.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in component_class.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
{% for i, sv in enumerate(component_class.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {
    // Set internal state variables from dictionary values
{% for i, sv in enumerate(component_class.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}

/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime({% if initial_regime %}{{initial_regime}}_REGIME{% else %}DEFAULT_REGIME_{% endif %}) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime({% if initial_regime %}{{initial_regime}}_REGIME{% else %}DEFAULT_REGIME_{% endif %}) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in component_class.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

{% include "init_solver.tmpl" %}
}


void {{component_name}}::reset_events() {
{% for port in component_class.event_send_ports %}
    B_.num_{{port.name}}_events = 0;
{% endfor %}
{% for port in component_class.event_receive_ports %}
    B_.num_unprocessed_{{port.name}}_events = B_.{{port.name}}_event_port.get_multiplicity();
{% endfor %}
}

/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {

    recordablesMap_.create();

    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler, []) | indent(8)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent(8)}}
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);

    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler, []) | indent(8)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent}}    
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);

    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler, []) | indent(8)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent}}    
}

/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
{% include "destructor.tmpl" %}
}

/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/

{% include "trigger_roots.tmpl" %}

/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    double dt = nest::Time::get_resolution().get_ms();
    nest::long_t current_steps = origin.get_steps();

    double f_[{{component_name}}::State_::STATE_VEC_SIZE_];  // Vector to hold the time derivatives

    for (nest::long_t lag = from; lag < to; ++lag) {

        /***** Solve ODE over timestep *****/

{% for regime in component_class.regimes %}
        {{elseif(loop.first)}} (B_.current_regime == {{regime.name}}_REGIME) {

            /***** Set clamp vars for state variables that don't have a time derivative in this regime *****/
    {% for sv in regime.no_time_derivatives(component_class.state_variables) %}
            double {{sv.name}}_clamp_ = S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX];
    {% endfor %} 

	        {% include "update_step.tmpl" %}
    
            /***** Reset state variables from clamp vars for state variables that don't have a time derivative in this regime *****/
    {% for sv in regime.no_time_derivatives(component_class.state_variables) %}
            S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX] = {{sv.name}}_clamp_;
    {% endfor %}    

    {% if debug %}
            std::cout << "Regime: {{regime.name}} at time " << t << std::endl;
    {% endif %}
        {{endif(loop.last)}} 
{% endfor %}

        /***** Transition handling *****/
        int transition_count = 0;
        double prev_t = -std::numeric_limits<double>::infinity();
        int transitioned_to;
        
        do {
{% for regime in component_class.regimes %}
            transitioned_to = -1;
	        {{elseif(loop.first)}} (B_.current_regime == {{regime.name}}_REGIME) {
	            // Map all variables/expressions to the local namespace that are required to evaluate the triggers
	            {{macros.map_required_vars_locally(chain(regime.all_triggers(), regime.all_target_triggers()), component_class, component_name, unit_handler, []) | indent(16)}}
		        
		        // FIXME: The transitions should be ordered by the exact time they occur to determine which should be executed first.

    {% for trans in regime.transitions %}
        {% set connection_parameters = [] %}{# passed to the previous_expressions argument of map_required_vars_locally #}
                // Get the time after the current step to test the trigger against
                double t = origin.get_ms() + lag * dt;        
        {% if hasattr(trans, 'trigger') %}{# OnCondition transition #}
	            // Check trigger condition
	            if ({{trans.trigger.rhs_cstr}}) {
           {% set exact_time_expr = trans.trigger.crossing_time_expr %}
           {% if exact_time_expr %}
                    // The trigger expression depends on 't' so determine the exact time that the threshold was crossed.
                    t = {{exact_time_expr.rhs_cstr}};
           {% endif %}
	            
	                // Check to see if trigger is active (i.e. was false since on the change from false->true triggers a transition)
	                if (B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active{% if exact_time_expr %} && t > prev_t{% endif %}) {
	                    // Deactivate the trigger (triggers are only triggered when the change from false -> true)
	                    B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active = false; 
	                    prev_t = t;
        {% else %}
	            // Check for incoming event
	            double {{trans.src_port_name}} = B_.{{trans.src_port_name}}_event_port.get_value(lag);
	
	            if ({{trans.src_port_name}}) {
            {% if trans.src_port_name in component_class.connection_parameter_set_names %}
                        // Set the "weight" of the event to the connection parameters paired to the analog port.
                {% for connection_param in component_class.connection_parameter_set(trans.src_port_name).parameters %}
                        double {{connection_param.name}} = {{trans.src_port_name}};  // ({{unit_handler.dimension_to_unit_str(connection_param.dimension)}})
                {% endfor %}
                {# Set the connection parameter sets to pass to the previously defined variables in the map_required_vars_locally macro #}
                {% set connection_parameters = component_class.connection_parameter_set(trans.src_port_name).parameters %}
            {% endif %}
        {% endif %}
                        // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers
                        {{macros.map_required_vars_locally(trans.state_assignments, component_class, component_name, unit_handler, chain(regime.all_triggers(), regime.all_target_triggers(), connection_parameters)) | indent(24)}}

				        // State assignments
        {% for sa, scaled_expr, units in unit_handler.scale_aliases(trans.state_assignments) %}
				        S_.y_[{{component_name}}::State_::{{sa.name}}_INDEX] = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}

					    // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
					    // Output events
        {% for output_event in trans.output_events %}
					    set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
					    nest::SpikeEvent se;
					    network()->send(*this, se, lag);
        {% endfor %}
        
                        // Set transition to new regime
                        B_.current_regime = transitioned_to = {{trans.target_regime.name}}_REGIME;
        {% if debug %}
                        std::cout << "Transitioned from {{regime.name}} to regime: {{trans.target_regime.name}} at time " << t << std::endl;
        {% endif %}
                        // FIXME: Need to work out the best way to emit a warning in NEST.                                    
                        if (transitioned_to != -1)  // If have already transitioned to a new regime, emit a warning. FIXME: This should be an error.
	                        std::cout << "Warning!: multiple transitions in the same time step. Transition to 'Regime " << transitioned_to << "' was ignored in favour of transition " << {{trans.target_regime.name}}_REGIME << "." << std::endl;
        
                        {{macros.set_triggers(trans.target_regime, component_class, component_name, unit_handler) | indent(20)}}
                        
                        // Increment the number of transitions that have occurred in this time step.
                        ++transition_count;
                                
        {% if hasattr(trans, 'trigger') %}
	                }
	            } else
                    // Activate the trigger
                    B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active = true;
        {% else %}
                }
        {% endif %} 
            {{endif(loop.last)}}            
    {% endfor %}
{% endfor %}
        } while (transitioned_to != -1 && transition_count < {{max_simultaneous_transitions}});
            
        if (transition_count >= {{max_simultaneous_transitions}}) {
            //FIXME: This should be an error not a warning.
            std::cout << "Warning!: Number of instantaneous transitions exceeds maxiumum number set by 'max_simultaneous_transitions' template parameter ({{max_simultaneous_transitions}})" << std::endl;
        } else if (transition_count > 0) {
{% include "reset_solver.tmpl" %}
{% if debug %}
            std::cout << "reset" << std::endl;
{% endif %}

        }

        /***** Get analog port values *****/
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}

        /***** Record data *****/
        B_.logger_.record_data(current_steps + lag);
    }
}

/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
{% for port in component_class.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        B_.{{port.name}}_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        B_.{{port.name}}_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace
