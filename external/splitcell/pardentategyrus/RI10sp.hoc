// This is a fully wired network that functions with 500 GCs and 1 PP input
//With spike raster and  write to file 
// Auto init and run

// The synaptic parameters need to be checked


secondorder=2 
tstep=0
period=2
dt=0.1
tstop=300	//1500

// define network size
ngcell = 500
nbcell = 6
nmcell = 15
nhcell = 6
npp = 1



 // Define EPSCs---- using:
//- an Exp2Syn object (parameters tau1 -rise, tau2 -decay, 
// time constant [ms] and e - rev potential [mV]
// delay [ms] and weight -variablr betw 0 and 1 [1 corresponding to 1 'S]


//***********************************************************************************************
//Defining granule cell
objref Gcell[ngcell]


	begintemplate GranuleCell


ndend1=4
ndend2=4
public  synlist, connect2target, subsets, is_art, is_connected
public  vbc2gc, vmc2gc, vhc2gc, vgc2bc, vbc2bc, vmc2bc, vhc2bc, vgc2mc, vbc2mc, vmc2mc, vhc2mc, vgc2hc, vmc2hc
public soma, gcdend1, gcdend2
public all, gcldend, pdend, mdend, ddend

nst=10
	objectvar stim[nst]
double stimdur[nst], stimdel[nst], stimamp[nst]
public stim, stimdur, stimamp, stimdel
create soma, gcdend1[ndend1], gcdend2[ndend2]
objref syn, synlist


proc init() {
	synlist = new List()
	subsets()
	gctemp()
	synapse()
}
objref all, gcldend, pdend, mdend, ddend
proc subsets(){ local i
	objref all, gcldend, pdend, mdend, ddend
	all = new SectionList()
		soma all.append()
		for i=0, 3 gcdend1 [i] all.append()
		for i=0, 3 gcdend2 [i] all.append()

	gcldend  = new SectionList()
		gcdend1 [0] gcldend.append()
		gcdend2 [0] gcldend.append()

	pdend  = new SectionList()
		gcdend1 [1] pdend.append()
		gcdend2 [1] pdend.append()

	mdend  = new SectionList()
		gcdend1 [2] mdend.append()
		gcdend2 [2] mdend.append()

	ddend  = new SectionList()
		gcdend1 [3] ddend.append()
		gcdend2 [3] ddend.append()
}
proc gctemp() {

	soma {nseg=1 L=16.8 diam=16.8} // changed L & diam
		
	gcdend1 [0] {nseg=1 L=50 diam=3}
	for i = 1, 3	gcdend1 [i] {nseg=1 L=150 diam=3}

	gcdend2 [0] {nseg=1 L=50 diam=3}
	for i = 1, 3	gcdend2 [i] {nseg=1 L=150 diam=3}	 	

    
	forsec all {
		insert ccanl
	catau_ccanl = 10
	caiinf_ccanl = 5.e-6
	Ra=210
	}

	soma {insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.12  //original 0.030 to .055 
	gkfbar_ichan2=0.016  //original 0.015
	gksbar_ichan2=0.006
		insert borgka
	gkabar_borgka=0.012
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.002  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.005
		insert cat
	gcatbar_cat=0.000037
		insert gskch
	gskbar_gskch=0.001
		insert cagk
	gkbar_cagk=0.0006
	gl_ichan2 = 0.00004
	cm=1

} 

		forsec gcldend {insert ichan2
	gnatbar_ichan2=0.018  //original 0.015
	gkfbar_ichan2=0.004
	gksbar_ichan2=0.006
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.003  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.0075
		insert cat
	gcatbar_cat=0.000075
		insert gskch
	gskbar_gskch=0.0004
		insert cagk
	gkbar_cagk=0.0006
	gl_ichan2 = 0.00004
	cm=1}
		
		forsec pdend {insert ichan2
	gnatbar_ichan2=0.013
	gkfbar_ichan2=0.004
	gksbar_ichan2=0.006
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.001  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.0075
		insert cat
	gcatbar_cat=0.00025
		insert gskch
	gskbar_gskch=0.0002
		insert cagk
	gkbar_cagk=0.001
	gl_ichan2 = 0.000063
	cm=1.6
	}
		
	 	forsec mdend {insert ichan2
	gnatbar_ichan2=0.008
	gkfbar_ichan2=0.001
	gksbar_ichan2=0.006
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.001  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.0005
		insert cat
	gcatbar_cat=0.0005
		insert gskch
	gskbar_gskch=0.0
		insert cagk
	gkbar_cagk=0.0024
	gl_ichan2 = 0.000063

	cm=1.6}

		forsec ddend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.001
	gksbar_ichan2=0.008
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.001  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.0
		insert cat
	gcatbar_cat=0.001
		insert gskch
	gskbar_gskch=0.0
		insert cagk
	gkbar_cagk=0.0024
	gl_ichan2 = 0.000063
	cm=1.6}
		
	
	connect gcdend1[0](0), soma(1)
	connect gcdend2[0](0), soma(1)
	for i=1,3 {
	connect gcdend1[i](0), gcdend1[i-1](1)
	}
	for i=1,3 {
	connect gcdend2[i](0), gcdend2[i-1](1)
	}


	forsec all {enat = 45 ekf = -90 eks = -90  ek=-90  elca=130 etca=130	 esk=-90
		 el_ichan2 =-70

		cao_ccanl=2 }  // make catau slower70e-3 	cao=2 cai=50.e-6 

// current injection
//for i=0,0 {
//stimdel[i]=500
//stimdur[i]=200
//stimamp[i]=0.2

//soma stim[i] = new IClamp(0.5)
//stim.del[i]=stimdel[i]
//stim.dur[i]=stimdur[i]
//stim.amp[i]=stimamp[i]
//}


		}
	proc connect2target() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
	//alternative statement		$o1.soma synlist.append(new NetCon(soma.v(1),syn,0,Delsyn,0))
	}

	objref syn
	proc synapse() {
	gcdend1[3] syn = new Exp2Syn(0.5) // PP syn based on Greg and Staley
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	gcdend2[3] syn = new Exp2Syn(0.5) // PPsyn based on Greg and Staley
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	gcdend1[1] syn = new Exp2Syn(0.5) // MC syn *** Estimated
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	gcdend2[1] syn = new Exp2Syn(0.5) // MC syn   *** Estimated
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	gcdend1[3] syn = new Exp2Syn(0.5) // HIPP  syn based on Harney and Jones corrected for temp
	syn.tau1 = 0.5	syn.tau2 = 6	syn.e = -70
	synlist.append(syn)

	gcdend2[3] syn = new Exp2Syn(0.5) // HIPP syn based on Harney and Jones corrected for temp
	syn.tau1 = 0.5	syn.tau2 = 6	syn.e = -70
	synlist.append(syn)

	soma syn = new Exp2Syn(0.5) // BC  syn syn based on Bartos
	syn.tau1 = 0.26	syn.tau2 = 5.5	syn.e = -70
	synlist.append(syn)

	gcdend1[1] syn = new Exp2Syn(0.5) // Sprouted Syn*************
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	gcdend2[1] syn = new Exp2Syn(0.5) // Sprouted Syn*********
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)


// Total of 7 synapses per GC 0,1 PP; 	2,3 MC;	4,5 HIPP and 	6 BC	7,8 Sprout
	}
	func is_art() { return 0 }

	endtemplate GranuleCell
// ************************************************************************************************************


objref Bcell[nbcell]

	begintemplate BasketCell
ndend1=4
ndend2=4
ndend3=4
ndend4=4

public  synlist, connect2target, subsets, is_art, is_connected
public vbc2gc, vmc2gc, vhc2gc, vgc2bc, vbc2bc, vmc2bc, vhc2bc, vgc2mc, vbc2mc, vmc2mc, vhc2mc, vgc2hc, vmc2hc
public soma, bcdend1, bcdend2, bcdend3, bcdend4
public all, adend, bdend, cdend, ddend
create soma, bcdend1[ndend1], bcdend2[ndend2], bcdend3[ndend3], bcdend4[ndend4]
objref syn, synlist
nst=10
	objectvar stim[nst]
double stimdur[nst], stimdel[nst], stimamp[nst]
public stim, stimdur, stimamp, stimdel


objref syn
proc init() {
	synlist = new List()
	subsets()
	temp()
	synapse()
}

objref all, adend, bdend, cdend, ddend

proc subsets() { local i
	objref all, adend, bdend, cdend, ddend
	all = new SectionList()
		soma all.append()
		for i=0, 3 bcdend1 [i] all.append()
		for i=0, 3 bcdend2 [i] all.append()
		for i=0, 3 bcdend3 [i] all.append()
		for i=0, 3 bcdend4 [i] all.append()

	adend  = new SectionList()
		bcdend1 [0] adend.append()
		bcdend2 [0] adend.append()
		bcdend3 [0] adend.append()
		bcdend4 [0] adend.append()

	bdend  = new SectionList()
		bcdend1 [1] bdend.append()
		bcdend2 [1] bdend.append()
		bcdend3 [1] bdend.append()
		bcdend4 [1] bdend.append()

	cdend  = new SectionList()
		bcdend1 [2] cdend.append()
		bcdend2 [2] cdend.append()
		bcdend3 [2] cdend.append()
		bcdend4 [2] cdend.append()

	ddend  = new SectionList()
		bcdend1 [3] ddend.append()
		bcdend2 [3] ddend.append()
		bcdend3 [3] ddend.append()
		bcdend4 [3] ddend.append()
}

proc temp() {

	soma {nseg=1 L=20 diam=15} // changed L & diam
		
	bcdend1 [0] {nseg=1 L=75 diam=4}	// bcdend 1 and 2 are apical
	bcdend1 [1] {nseg=1 L=75 diam=3}
	bcdend1 [2] {nseg=1 L=75 diam=2}
 	bcdend1 [3] {nseg=1 L=75 diam=1}

	bcdend2 [0] {nseg=1 L=75 diam=4}
	bcdend2 [1] {nseg=1 L=75 diam=3}
	bcdend2 [2] {nseg=1 L=75 diam=2}
	bcdend2 [3] {nseg=1 L=75 diam=1}
 		 
	bcdend3 [0] {nseg=1 L=50 diam=4} 	// bcdend 3 and 4 are basal
	bcdend3 [1] {nseg=1 L=50 diam=3}
	bcdend3 [2] {nseg=1 L=50 diam=2}
	bcdend3 [3] {nseg=1 L=50 diam=1} 
	
	bcdend4 [0] {nseg=1 L=50 diam=4}
	bcdend4 [1] {nseg=1 L=50 diam=3}
	bcdend4 [2] {nseg=1 L=50 diam=2}
	bcdend4 [3] {nseg=1 L=50 diam=1} 	

    
	forsec all {
		insert ccanl
	catau_ccanl = 10
	caiinf_ccanl = 5.e-6
		insert borgka
	gkabar_borgka=0.00015
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.0008   //check to modify- original 0.004
		insert lca 
	glcabar_lca=0.005
		insert gskch
	gskbar_gskch=0.000002
		insert cagk
	gkbar_cagk=0.0002
	}

	soma {insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.12  //original 0.030 to .055 
	gkfbar_ichan2=0.013  //original 0.015
	gl_ichan2 = 0.00018
	cm=1.4
	} 

	forsec adend {insert ichan2
	gnatbar_ichan2=0.12  //original 0.015
	gkfbar_ichan2=0.013
	gl_ichan2 = 0.00018
	cm=1.4
	}		
	forsec	bdend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
	cm=1.4}
		
	forsec 	cdend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
	cm=1.4}

	forsec	ddend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
	cm=1.4}


	connect bcdend1[0](0), soma(1)
	connect bcdend2[0](0), soma(1)
	connect bcdend3[0](0), soma(0)
	connect bcdend4[0](0), soma(0)
	for i=1,3 {
	connect bcdend1[i](0), bcdend1[i-1](1)
	}
	for i=1,3 {
	connect bcdend2[i](0), bcdend2[i-1](1)
	}
	for i=1,3 {
	connect bcdend3[i](0), bcdend3[i-1](1)
	}
	for i=1,3 {
	connect bcdend4[i](0), bcdend4[i-1](1)
	}


	forsec all {Ra=100}
	forsec all {enat = 55 ekf = -90  ek=-90  elca=130	esk=-90
		 el_ichan2 =-60.06

		cao_ccanl=2 }  // make catau slower70e-3 	cao=2 cai=50.e-6 

//for i=0,0 {
//stimdel[i]=1000
//stimdur[i]=200
//stimamp[i]=0.5

/* 0.4 stim when we want the cell to fire with regular spikes */

//soma stim[i] = new IClamp(0.5)
//stim.del[i]=stimdel[i]
//stim.dur[i]=stimdur[i]
//stim.amp[i]=stimamp[i]
//}
		}

	objref syn  
	proc synapse() {

	bcdend1 [3] syn = new Exp2Syn(0.5)	//PP(AMPA) syn to apical dist dend Dingledine '95
	syn.tau1 = 2	syn.tau2 = 6.3	syn.e = 0 // *** check Tau rise 2ms is the rise time
	synlist.append(syn)

	bcdend2 [3] syn = new Exp2Syn(0.5)	//PP(AMPA) syn to apical dist dend Dingledine '95
	syn.tau1 = 2	syn.tau2 = 6.3	syn.e = 0  // *** check Tau rise 2ms is the rise time
	synlist.append(syn)

	bcdend1 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend Geiger '97
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	bcdend2 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend Geiger '97
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	bcdend3 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend Geiger '97
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	bcdend4 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend Geiger '97
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	bcdend1 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to apical IML dend
	syn.tau1 = 0.9	syn.tau2 = 3.6	syn.e = 0 // *** Estimated based on CA3>BC min stim Dingledine '95
	synlist.append(syn)

	bcdend2 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to apical IML dend
	syn.tau1 = 0.9	syn.tau2 = 3.6	syn.e = 0 // *** Estimated based on CA3>BC min stim Dingledine '95
	synlist.append(syn)

	bcdend1 [1] syn = new Exp2Syn(0.5)	//BC(GABA) syn to apical IML dend Bartos
	syn.tau1 = 0.16		syn.tau2 = 1.8	syn.e = -70
	synlist.append(syn)

	bcdend2 [1] syn = new Exp2Syn(0.5)	//BC(GABA) syn to apical IML dend Bartos
	syn.tau1 = 0.16		syn.tau2 = 1.8	syn.e = -70
	synlist.append(syn)

	bcdend1 [3] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to apical distal dend 
	syn.tau1 = 0.4	syn.tau2 = 5.8	syn.e = -70 // *** Estimated as HIPP>GC
	synlist.append(syn)

	bcdend2 [3] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to apical distal dend 
	syn.tau1 = 0.4	syn.tau2 = 5.8	syn.e = -70 // *** Estimated as HIPP>GC
	synlist.append(syn)

// Total of 12 synapses 	0,1 PP; 	2-5 GC; 	6,7 MC; 	8,9 BC; 	10,11 HIPP 
	}

	proc connect2target() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
	//alternative statement		$o1.soma synlist.append(new NetCon(soma.v(1),syn,0,Delsyn,0))
	}

	func is_art()  { return 0 }

	endtemplate BasketCell
//***********************************************************************************************************
objref Mcell[nmcell]

	begintemplate MossyCell
ndend1=4
ndend2=4
ndend3=4
ndend4=4

public  synlist, connect2target, subsets, is_art, is_connected
public vbc2gc, vmc2gc, vhc2gc, vgc2bc, vbc2bc, vmc2bc, vhc2bc, vgc2mc, vbc2mc, vmc2mc, vhc2mc, vgc2hc, vmc2hc
public soma, mcdend1, mcdend2, mcdend3, mcdend4
create soma, mcdend1[ndend1], mcdend2[ndend2], mcdend3[ndend3], mcdend4[ndend4]
public all, adend, bdend, cdend, ddend
objref syn, synlist, fl
nst=10
	objectvar stim[nst]
double stimdur[nst], stimdel[nst], stimamp[nst]
public stim, stimdur, stimamp, stimdel


objref syn
proc init() {
	synlist = new List()
	subsets()
	temp()
	synapse()
}

objref all, pdend, ddend

proc subsets() { local i
	objref all, pdend, ddend
	all = new SectionList()
		soma all.append()
		for i=0, 3 mcdend1 [i] all.append()
		for i=0, 3 mcdend2 [i] all.append()
		for i=0, 3 mcdend3 [i] all.append()
		for i=0, 3 mcdend4 [i] all.append()

	pdend  = new SectionList()
		mcdend1 [0] pdend.append()
		mcdend2 [0] pdend.append()
		mcdend3 [0] pdend.append()
		mcdend4 [0] pdend.append()

	ddend  = new SectionList()
		for i=1, 3 mcdend1 [i] ddend.append()
		for i=1, 3 mcdend2 [i] ddend.append()
		for i=1, 3 mcdend3 [i] ddend.append()
		for i=1, 3 mcdend4 [i] ddend.append()
	
}


proc temp() {

	soma {nseg=1 L=20 diam=20} // changed L & diam
		
	mcdend1 [0] {nseg=1 L=50 diam=5.78}
	mcdend1 [1] {nseg=1 L=50 diam=4}
	mcdend1 [2] {nseg=1 L=50 diam=2.5}
 	mcdend1 [3] {nseg=1 L=50 diam=1}

	mcdend2 [0] {nseg=1 L=50 diam=5.78}
	mcdend2 [1] {nseg=1 L=50 diam=4}
	mcdend2 [2] {nseg=1 L=50 diam=2.5}
	mcdend2 [3] {nseg=1 L=50 diam=1}
 		 
	mcdend3 [0] {nseg=1 L=50 diam=5.78}
	mcdend3 [1] {nseg=1 L=50 diam=4}
	mcdend3 [2] {nseg=1 L=50 diam=2.5}
	mcdend3 [3] {nseg=1 L=50 diam=1} 
	
	mcdend4 [0] {nseg=1 L=50 diam=5.78}
	mcdend4 [1] {nseg=1 L=50 diam=4}
	mcdend4 [2] {nseg=1 L=50 diam=2.5}
	mcdend4 [3] {nseg=1 L=50 diam=1} 	

    
	forall {
		insert ccanl
	catau_ccanl = 10
	caiinf_ccanl = 5.e-6
		insert borgka
	gkabar_borgka=0.00001
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.00008  // check to modify- original 0.004
		insert lca 
	glcabar_lca=0.0006
		insert gskch
	gskbar_gskch=0.016
		insert cagk
	gkbar_cagk=0.0165
		insert hyperde3
	ghyfbar_hyperde3=0.000005
	ghysbar_hyperde3=0.000005
	}

	soma {insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.12  //original 0.030 to .055 
	gkfbar_ichan2=0.0005  //original 0.015
	gl_ichan2 = 0.000011
	cm=0.6} 

	forsec pdend {insert ichan2
	gnatbar_ichan2=0.12  //original 0.015
	gkfbar_ichan2=0.0005
	gl_ichan2 = 0.000044
	cm=2.4}
		
	forsec ddend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.000044
	cm=2.4}
		
	connect mcdend1[0](0), soma(1)
	connect mcdend2[0](0), soma(1)
	connect mcdend3[0](0), soma(0)
	connect mcdend4[0](0), soma(0)
	for i=1,3 {connect mcdend1[i](0), mcdend1[i-1](1)}
	for i=1,3 {connect mcdend2[i](0), mcdend2[i-1](1)}
	for i=1,3 {connect mcdend3[i](0), mcdend3[i-1](1)}
	for i=1,3 {connect mcdend4[i](0), mcdend4[i-1](1)}

	forall {Ra=100}
	forall {enat = 55 ekf = -90  ek=-90  esk=-90 elca=130
		ehyf=-40 ehys=-40
		 el_ichan2 =-59

		cao_ccanl=2 }  // make catau slower70e-3 	cao=2 cai=50.e-6 

//for i=0,0 {
//stimdel[i]=500
//stimdur[i]=500
//stimamp[i]=0.2

/* 0.4 stim when we want the cell to fire with regular spikes */

//soma stim[i] = new IClamp(0.5)
//stim.del[i]=stimdel[i]
//stim.dur[i]=stimdur[i]
//stim.amp[i]=stimamp[i]
//}
//objref fl
//soma fl = new Gfluct2(0.5)
//fl.g_e0 = 0.0242
//fl.g_i0 = 0.1146
//fl.std_e = 0.0375
//fl.std_i = 0.01875


		}
	objref syn  
	proc synapse() {

	mcdend1 [3] syn = new Exp2Syn(0.7)	//PP(AMPA) syn to dist dend similar to PP to GC
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	mcdend2 [3] syn = new Exp2Syn(0.7)	//PP(AMPA) syn to dist dend similar to PP to GC
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	mcdend3 [3] syn = new Exp2Syn(0.7)	//PP(AMPA) syn to dist dend similar to PP to GC
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	mcdend4 [3] syn = new Exp2Syn(0.7)	//PP(AMPA) syn to dist dend similar to PP to GC
	syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
	synlist.append(syn)

	mcdend1 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>CA3 Jonas '93
	syn.tau1 = 0.5	syn.tau2 = 6.2	syn.e = 0
	synlist.append(syn)

	mcdend2 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>CA3 Jonas '93
	syn.tau1 = 0.5	syn.tau2 = 6.2	syn.e = 0
	synlist.append(syn)

	mcdend3 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>CA3 Jonas '93
	syn.tau1 = 0.5	syn.tau2 = 6.2	syn.e = 0
	synlist.append(syn)

	mcdend4 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>CA3 Jonas '93
	syn.tau1 = 0.5	syn.tau2 = 6.2	syn.e = 0
	synlist.append(syn)

	mcdend1 [0] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to prox dend similar to CA#>CA3 Aaron
	syn.tau1 = 0.45 	syn.tau2 =2.2	syn.e = 0
	synlist.append(syn)

	mcdend2 [0] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to prox dend similar to CA#>CA3 Aaron
	syn.tau1 = 0.45	syn.tau2 = 2.2		syn.e = 0
	synlist.append(syn)

	mcdend3 [0] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to prox dend similar to CA#>CA3 Aaron
	syn.tau1 = 0.45	syn.tau2 = 2.2	syn.e = 0
	synlist.append(syn)

	mcdend4 [0] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to prox dend similar to CA#>CA3 Aaron
	syn.tau1 = 0.45	syn.tau2 = 2.2	syn.e = 0
	synlist.append(syn)

	soma syn = new Exp2Syn(0.5)	//BC(GABA) syn to prox dend based on BC>CA3 Bartos PNAS (mice)
	syn.tau1 = 0.3	syn.tau2 = 3.3	syn.e = -70
	synlist.append(syn)

	mcdend1 [2] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to prox dend based on Hilar>GC Harney&Jones
	syn.tau1 = .5	syn.tau2 = 6		syn.e = -70
	synlist.append(syn)

	mcdend2 [2] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to prox dend based on Hilar>GC Harney&Jones
	syn.tau1 = .5	syn.tau2 = 6		syn.e = -70
	synlist.append(syn)

	mcdend3 [2] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to prox dend based on Hilar>GC Harney&Jones
	syn.tau1 = .5	syn.tau2 = 6		syn.e = -70
	synlist.append(syn)

	mcdend4 [2] syn = new Exp2Syn(0.5)	//HIPP(GABA) syn to prox dend based on Hilar>GC Harney&Jones
	syn.tau1 = .5	syn.tau2 = 6	syn.e =-70
	synlist.append(syn)

	

// Total of 17 synapses 	0-3 PP; 	4-7 GC; 	8-11 MC; 	12 BC; 	13-16 HIPP 
	}

	proc connect2target() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
	}

	func is_art()  { return 0 }

	endtemplate MossyCell

//**************************************************************************************************
objref Hcell[nhcell]

	begintemplate HIPPCell

ndend1=3
ndend2=3
ndend3=3
ndend4=3
public  synlist, connect2target, subsets, is_art, is_connected
public vbc2gc, vmc2gc, vhc2gc, vgc2bc, vbc2bc, vmc2bc, vhc2bc, vgc2mc, vbc2mc, vmc2mc, vhc2mc, vgc2hc, vmc2hc
public soma, hcdend1, hcdend2, hcdend3, hcdend4
create soma, hcdend1[ndend1], hcdend2[ndend2], hcdend3[ndend3], hcdend4[ndend4]
public all, pdend, ddend
objref syn, synlist
nst=10
	objectvar stim[nst]
double stimdur[nst], stimdel[nst], stimamp[nst]
public stim, stimdur, stimamp, stimdel


objref syn
proc init() {
	synlist = new List()
	subsets()
	temp()
	synapse()
}

objref all, pdend, ddend

proc subsets() { local i
	objref all, pdend, ddend
	all = new SectionList()
		soma all.append()
		for i=0, 2 hcdend1 [i] all.append()
		for i=0, 2 hcdend2 [i] all.append()
		for i=0, 2 hcdend3 [i] all.append()
		for i=0, 2 hcdend4 [i] all.append()

	pdend  = new SectionList()
		hcdend1 [0] pdend.append()
		hcdend2 [0] pdend.append()
		hcdend3 [0] pdend.append()
		hcdend4 [0] pdend.append()

	ddend  = new SectionList()
		for i=1, 2 hcdend1 [i] ddend.append()
		for i=1, 2 hcdend2 [i] ddend.append()
		for i=1, 2 hcdend3 [i] ddend.append()
		for i=1, 2 hcdend4 [i] ddend.append()
}

proc temp() {

	soma {nseg=1 L=20 diam=10} // changed L & diam
		
	hcdend1 [0] {nseg=1 L=75 diam=3}
	hcdend1 [1] {nseg=1 L=75 diam=2}
	hcdend1 [2] {nseg=1 L=75 diam=1}

	hcdend2 [0] {nseg=1 L=75 diam=3}
	hcdend2 [1] {nseg=1 L=75 diam=2}
	hcdend2 [2] {nseg=1 L=75 diam=1}
 		 
	hcdend3 [0] {nseg=1 L=50 diam=3}
	hcdend3 [1] {nseg=1 L=50 diam=2}
	hcdend3 [2] {nseg=1 L=50 diam=1}
	
	hcdend4 [0] {nseg=1 L=50 diam=3}
	hcdend4 [1] {nseg=1 L=50 diam=2}
	hcdend4 [2] {nseg=1 L=50 diam=1}	

    
	forall {
		insert ccanl
	catau_ccanl = 10
	caiinf_ccanl = 5.e-6
		insert borgka
	gkabar_borgka=0.0008
		insert nca  // HAV-N- Ca channel
	gncabar_nca=0.0  //0005  check to modify- original 0.004
		insert lca
	glcabar_lca=0.0015
		insert gskch
	gskbar_gskch=0.003
		insert cagk
	gkbar_cagk=0.003
		insert hyperde3
	ghyfbar_hyperde3=0.000015
	ghysbar_hyperde3=0.000015
	}

	soma {insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.2  //original 0.030 to .055 
	gkfbar_ichan2=0.006  //original 0.015
	gl_ichan2 = 0.000036
	cm=1.1} 

	forsec pdend {insert ichan2
	gnatbar_ichan2=0.2  //original 0.015
	gkfbar_ichan2=0.006
	gl_ichan2 = 0.000036
	cm=1.1}
		
	forsec ddend {insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.000036
	cm=1.1}

	connect hcdend1[0](0), soma(1)
	connect hcdend2[0](0), soma(1)
	connect hcdend3[0](0), soma(0)
	connect hcdend4[0](0), soma(0)
	for i=1,2 {connect hcdend1[i](0), hcdend1[i-1](1)}
	for i=1,2 {connect hcdend2[i](0), hcdend2[i-1](1)}
	for i=1,2 {connect hcdend3[i](0), hcdend3[i-1](1)}
	for i=1,2 {connect hcdend4[i](0), hcdend4[i-1](1)}

	forall {Ra=100}
	forall {enat = 55 ekf = -90  ek=-90  esk=-90 elca=130
		 el_ichan2 =-70.45	ehyf=-40 ehys=-40
		cao_ccanl=2 }  // make catau slower70e-3 	cao=2 cai=50.e-6 

//for i=0,0 {
//stimdel[i]=500
//stimdur[i]=500
//stimamp[i]=0.1

/* 0.4 stim when we want the cell to fire with regular spikes */

//soma stim[i] = new IClamp(0.5)
//stim.del[i]=stimdel[i]
//stim.dur[i]=stimdur[i]
//stim.amp[i]=stimamp[i]
//}
		}

	objref syn  
	proc synapse() {

	hcdend1 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>BC
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	hcdend2 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>BC
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	hcdend3 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>BC
	syn.tau1 = .3 syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	hcdend4 [0] syn = new Exp2Syn(0.5)	//GC(AMPA) syn to prox dend similar to GC>BC
	syn.tau1 = .3	syn.tau2 = .6	syn.e = 0
	synlist.append(syn)

	hcdend1 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to mid dend similar to CA3>int Aaron
	syn.tau1 = .9	syn.tau2 = 3.6	syn.e = 0 //*** Assumed data at physio temp
	synlist.append(syn)

	hcdend2 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to mid dend similar to CA3>int Aaron
	syn.tau1 = 0.9	syn.tau2 = 3.6	syn.e = 0 //*** Assumed data at physio temp
	synlist.append(syn)

	hcdend3 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to mid dend similar to CA3>int Aaron
	syn.tau1 = 0.9	syn.tau2 = 3.6	syn.e = 0  //*** Assumed data at physio temp
	synlist.append(syn)

	hcdend4 [1] syn = new Exp2Syn(0.5)	//MC(AMPA) syn to mid dend similar to CA3>int Aaron
	syn.tau1 = 0.9		syn.tau2 = 3.6 	syn.e = 0  //*** Assumed data at physio temp
	synlist.append(syn)

// Total of 12 synapses 	0-3 PP; 	4-7 GC; 	8-11 MC	
	}

	proc connect2target() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
	}

	func is_art()  { return 0 }


	endtemplate HIPPCell
//************************************************************************************************************


objref PPSt[npp]

	begintemplate PPstim

	public pp, connect2target, is_art, acell
	create acell
	objref pp

	proc init() {
		actemp() 		
	}
		proc actemp() {
				acell pp = new NetStim(.5)
				pp.interval = 100
				pp.number = 1
				pp.start = 5
				}

	func is_art() {return 1}
	proc connect2target() {acell $o2 = new NetCon(pp, $o1)}

	endtemplate PPstim
//###############################################################################################################
	
// NETWORK SPECIFICATION INTERFACE
	for i=0, ngcell-1 {Gcell[i] = new GranuleCell(i)}
	for i=0, nbcell-1 {Bcell[i] = new BasketCell(i)}
	for i=0, nmcell-1 {Mcell[i] = new MossyCell(i)}
	for i=0, nhcell-1 {Hcell[i] = new HIPPCell(i)}
	for i =0, npp-1 {PPSt[i] = new PPstim(i)}

objref nclist, netcon, cells, net_c, net_d, net_gr,  net_bc,  net_mc,  net_hc,  vbc2gc, vmc2gc, vhc2gc
{  cells = new List()
nclist = new List()
}
 func cell_append() {cells.append($o1) 
	return cells.count -1}

func nc_append() {

	if ($3 >= 0 )	{
		cells.object($1).connect2target(cells.object($2).synlist.object($3),netcon)
		netcon.weight = $4	netcon.delay = $5	netcon.threshold = $6
	} 
	nclist.append(netcon)
	return nclist.count-1
		}

func is_connected() {local i, c
	c=0
	for i=0, nclist.count-1 {
	net_c= nclist.object(i)
	if (($o1 == net_c.postcell())  && ($o2 == net_c.precell())) {c=1}
}
return c
}



objref vbc2gc, vmc2gc, vhc2gc, vgc2bc, vbc2bc, vmc2bc, vhc2bc, vgc2mc, vbc2mc, vmc2mc, vhc2mc, vgc2hc, vmc2hc,vgc2gc

	{
	vgc2bc = new Vector(nbcell, 0)
	vbc2bc = new Vector(nbcell, 0)
	vmc2bc = new Vector(nbcell, 0)
	vhc2bc = new Vector(nbcell, 0)

	vgc2mc = new Vector(nmcell, 0)
	vbc2mc = new Vector(nmcell, 0)
	vmc2mc = new Vector(nmcell, 0)
	vhc2mc = new Vector(nmcell, 0)


	vgc2hc = new Vector(nhcell, 0)
	vmc2hc = new Vector(nhcell, 0)

	vbc2gc = new Vector(ngcell, 0)
	vmc2gc = new Vector(ngcell, 0)
	vhc2gc = new Vector(ngcell, 0)
	vgc2gc = new Vector(ngcell, 0)
	}




//initiating randm number generator

objref rdsynb, rdsyna, rdgc2hc, rdgc2bc, rdgc2mc, rdbc2gc, rdbc2bc, rdbc2mc
objref rdmc2gc1, rdmc2gc2, rdmc2bc, rdmc2mc, rdmc2mc1, rdmc2hc, rdhc2gc, rdhc2bc, rdhc2mc, rdgc2gc
ropen("/proc/uptime")		// get a seed  that is changing based on the processing time
	 {			
 	rseed = fscan()		// so simulation will not start with the same seed
	ropen()		
	}
rseed = 0
hindx = 1
hindx_inc = 1e6
//************************************GC***********************************************
rdgc2bc = new Random(rseed)			// use for syn.connections 
rdgc2bc.MCellRan4(hindx += hindx_inc)
proc new_rdgc2bc() {rdgc2bc.discunif(-1,1)}
new_rdgc2bc()
rdgc2mc = new Random(rseed)			// use for syn.connections 
rdgc2mc.MCellRan4(hindx += hindx_inc)
proc new_rdgc2mc() {rdgc2mc.discunif(0,2)}
new_rdgc2mc()
rdgc2hc = new Random(rseed)			// use for syn.connections 
rdgc2hc.MCellRan4(hindx += hindx_inc)
proc new_rdgc2hc() {rdgc2hc.discunif(-2 , 2)}
new_rdgc2hc()
rdgc2gc = new Random(rseed)			// use for syn.connections 
rdgc2gc.MCellRan4(hindx += hindx_inc)
proc new_rdgc2gc() {rdgc2gc.discunif(-50, 50)}
new_rdgc2gc()

//************************************BC***********************************************
rdbc2gc = new Random(rseed)			// use for syn.connections 
rdbc2gc.MCellRan4(hindx += hindx_inc)
proc new_rdbc2gc() {rdbc2gc.discunif(0, ngcell-1)}
new_rdbc2gc()
rdbc2bc = new Random(rseed)			// use for syn.connections 
rdbc2bc.MCellRan4(hindx += hindx_inc)
proc new_rdbc2bc() {rdbc2bc.discunif(ngcell, ngcell+nbcell-1)}
new_rdbc2bc()
rdbc2mc = new Random(rseed)			// use for syn.connections 
rdbc2mc.MCellRan4(hindx += hindx_inc)
proc new_rdbc2mc() {rdbc2mc.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1)}
new_rdbc2mc()

//*************************************MC********************************************
rdmc2gc1 = new Random(rseed)			// use for syn.connections 
rdmc2gc1.MCellRan4(hindx += hindx_inc)
proc new_rdmc2gc1() {rdmc2gc1.discunif(25, 175)}
new_rdmc2gc1()
rdmc2gc2 = new Random(rseed)			// use for syn.connections 
rdmc2gc2.MCellRan4(hindx += hindx_inc)
proc new_rdmc2gc2() {rdmc2gc2.discunif(-175, -25)}
new_rdmc2gc2()
rdmc2bc = new Random(rseed)			// use for syn.connections 
rdmc2bc.MCellRan4(hindx += hindx_inc)
proc new_rdmc2bc() {rdmc2bc.discunif(-3,3)}
new_rdmc2bc()
rdmc2mc = new Random(rseed)			// use for syn.connections 
rdmc2mc.MCellRan4(hindx += hindx_inc)
proc new_rdmc2mc() {rdmc2mc.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1)}
new_rdmc2mc()
rdmc2mc1 = new Random(rseed)			// use for syn.connections 
rdmc2mc1.MCellRan4(hindx += hindx_inc)
proc new_rdmc2mc1() {rdmc2mc1.discunif(-3, 3)}
new_rdmc2mc1()
rdmc2hc = new Random(rseed)			// use for syn.connections 
rdmc2hc.MCellRan4(hindx += hindx_inc)
proc new_rdmc2hc() {rdmc2hc.discunif(-2, 2)}
new_rdmc2hc()
//*************************************HC********************************************

rdhc2gc = new Random(rseed)			// use for syn.connections 
rdhc2gc.MCellRan4(hindx += hindx_inc)
proc new_rdhc2gc() {rdhc2gc.discunif(0, ngcell-1)}
new_rdhc2gc()
rdhc2bc = new Random(rseed)			// use for syn.connections 
rdhc2bc.MCellRan4(hindx += hindx_inc)
proc new_rdhc2bc() {rdhc2bc.discunif(ngcell, ngcell+nbcell-1)}
new_rdhc2bc()
rdhc2mc = new Random(rseed)			// use for syn.connections 
rdhc2mc.MCellRan4(hindx += hindx_inc)
proc new_rdhc2mc() {rdhc2mc.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1)}
new_rdhc2mc()

//*********************************************************************************

rdsyna = new Random(rseed)		// initialize random distr.
rdsyna.MCellRan4(hindx += hindx_inc)
proc new_rdsyna() {rdsyna.discunif(0, 1)}
new_rdsyna()

rdsynb = new Random(rseed)		// initialize random distr.
rdsynb.MCellRan4(hindx += hindx_inc)
proc new_rdsynb() {rdsynb.discunif(0, 3)}
new_rdsynb()

//	NETWORK INITIATION
	for i = 0, ngcell-1 {cell_append(Gcell[i])} // cells 0-4 GCs
	for i = 0, nbcell-1 {cell_append(Bcell[i])} // cells 5-6 BC
	for i = 0, nmcell-1 {cell_append(Mcell[i])} // cell 7 MC
	for i = 0, nhcell-1 {cell_append(Hcell[i])} // cell 8 HC
	for i = 0, npp-1 {cell_append(PPSt[i])}	// cell 9 PP

//**************Preforant Path  synaptic connections ******************************
proc initNet() { local i,j
for i=0, npp-1 {
		for j=0, 99 {	//ngcell-1{
	nc_append(i+ngcell+nbcell+nmcell+nhcell, j, 0, 2e-2, 3, 10)  // Gcell[3] to Bcell[1]
	nc_append(i+ngcell+nbcell+nmcell+nhcell, j, 1, 2e-2, 3, 1)  // Gcell[3] to Bcell[1]
	}

	for j= ngcell, ngcell { //ngcell+nbcell-1{
	nc_append(ngcell+nbcell+nmcell+nhcell, j, 0, 1e-2, 3, 10)  // Gcell[3] to Bcell[1]
	nc_append(ngcell+nbcell+nmcell+nhcell, j, 1, 1e-2, 3, 10)  // Gcell[3] to Bcell[1]
	}

	for j=0, 0 { 	// 15% of MCs have OML dendrites
	 npost = rdmc2mc.repick()
	dbr = rdsynb.repick()
	if ((is_connected(MossyCell[npost-ngcell-nbcell], PPstim[0]) == 0) && (npost < ngcell+nbcell+3)) {
	nc_append(ngcell+nbcell+nmcell+nhcell, npost, dbr, 0.5e-2, 3, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr
	} else {	j -= 1	print "pp2mc"}
	}

}
//******************************************************************************************

//**************Granule Cell post synaptic connections ******************************


for  i=0, ngcell-1 {

	for j=0, 1 {

	if (i < 84) { a=0}
	if ((i > 83) && (i < 166)) { a=1}
	if ((i > 165) && (i < 252)) { a=2}
	if ((i > 251) && (i < 336)) { a=3}
	if ((i > 335) && (i < 420)) { a=4}
	if ((i > 419) && (i < 500)) { a=5}

	 Gauz3 = rdgc2bc.repick()
	if (a+Gauz3 > 5) {npost = a+Gauz3-6 }
	if (a+Gauz3 < 0) {npost = a+Gauz3+6} 
	if ((a+Gauz3 > -1) && (a+Gauz3 < 6)) {npost = a+Gauz3}
	dbr = rdsynb.repick()
	print npost, a
	if ((is_connected(BasketCell[npost], GranuleCell[i]) == 0) && (vgc2bc.x[npost] < 180))  {
	nc_append(i, ngcell+npost, dbr+2, 4.7e-3, .8, 10)  // Gcell[3] to Bcell[1]
	print i, npost, dbr+2
	vgc2bc.x[npost]  +=1
	} else {j -= 1	print "sdtf"}
	}

	for j=0, 0 {
	if (i < 100) { a=0}
	if ((i > 99) && (i < 200)) { a=1}
	if ((i > 199) && (i < 300)) { a=2}
	if ((i > 299) && (i < 400)) { a=3}
	if ((i > 399) && (i < 500)) { a=4}
	b=a*3
	 npost = rdgc2mc.repick()
	dbr = rdsynb.repick()
//	print npost, b
	if ((is_connected(MossyCell[npost+b], GranuleCell[i]) == 0) && (vgc2mc.x[npost+b] < 38)){
	nc_append(i, ngcell+nbcell+npost+b, dbr+4, 0.2e-3, 1.5, 10)  // Gcell[3] to Bcell[1]
	print npost+b, dbr+4
	vgc2mc.x[npost+b] +=1
	} else {	j -= 1	print "mdtf"}
	}

	for j=0, 2 {
	if (i < 84) { a=0}
	if ((i > 83) && (i < 166)) { a=1}
	if ((i > 165) && (i < 252)) { a=2}
	if ((i > 251) && (i < 336)) { a=3}
	if ((i > 335) && (i < 420)) { a=4}
	if ((i > 419) && (i < 500)) { a=5}
	 Gauz3 = rdgc2hc.repick()
	if (a+Gauz3 > 5) {npost = a+Gauz3-6 }
	if (a+Gauz3 < 0) {npost = a+Gauz3+6} 
	if ((a+Gauz3 > -1) && (a+Gauz3 < 6)) {npost = a+Gauz3}
	dbr = rdsynb.repick()
	if ((is_connected(HIPPCell[npost], GranuleCell[i]) == 0) && (vgc2hc.x[npost] < 270)) {
	nc_append(i, ngcell+nbcell+nmcell+npost, dbr, 0.5e-3, 1.5, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr
	vgc2hc.x[npost] +=1
	} else {j -= 1	print "hhhh"}
	}

	for j=0, 9 {
	 Gauz3 = rdgc2gc.repick()
//print Gauz3
	if (i+Gauz3 > 499) {npost = i+Gauz3-500 }
	if (i+Gauz3 < 0) {npost = i+Gauz3+500} 
	if ((i+Gauz3 > -1) && (i+Gauz3 < 500)) {npost = i+Gauz3}
//print npost
	dbr = rdsyna.repick()
	if ((is_connected(GranuleCell[npost], GranuleCell[i]) == 0) && (vgc2gc.x[npost] < 15)) {
	nc_append(i, npost, dbr+7, 2e-3, .8, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr+8
	vgc2gc.x[npost] +=1
	} else {j -= 1	print "gc2gc"}
	}
}
//******************************************************************************************

//**************Basket Cell post synaptic connections ******************************



//for  i=0, nbcell-1 {
	
//		for j=0, 99 {
//	 npost = rdbc2gc.repick()
//	if ((is_connected(GranuleCell[npost], BasketCell[i]) == 0) && (vbc2gc.x[npost] < 2)) {
//	nc_append(i+ngcell, npost, 6, 1.6e-3, .85, 10)  // Gcell[3] to Bcell[1]
//	vbc2gc.x[npost] +=1
//	print i, npost, 6
//	} else {j -= 1	print "BC2GC"}
//	}

//	for j=0, 1 {
//	 npost = rdbc2bc.repick()
//	dbr = rdsyna.repick()
//	if ((is_connected(BasketCell[npost-ngcell], BasketCell[i]) == 0) && (vbc2bc.x[npost-ngcell] < 3)) {
//	nc_append(i+ngcell, npost, dbr+8, 7.6e-3, .8, 10)  // Gcell[3] to Bcell[1]
//	print npost, dbr+8
//	vbc2bc.x[npost-ngcell] +=1
//	} else {j -= 1	print "bc2bc"}
//	}

//	for j=0, 4 {
//	 npost = rdbc2mc.repick()
//	if ((is_connected(MossyCell[npost-ngcell-nbcell], BasketCell[i]) == 0) && (vbc2mc.x[npost-ngcell-nbcell] < 3)) {
//	nc_append(i+ngcell, npost, 12, 1.5e-3, 1.5, 10)  // Gcell[3] to Bcell[1]
//	print npost, 12
//	vbc2mc.x[npost-ngcell-nbcell] +=1
//	} else {	j -= 1	print "bc2mc"}
//	}


//}
//******************************************************************************************

//**************Mossy Cell post synaptic connections ******************************



for  i=0, nmcell-1 {
	if (i < 3) { y=0}
	if ((i > 2) && (i < 6)) { y=1}
	if ((i > 5) && (i < 9)) { y=2}
	if ((i > 8) && (i < 12)) { y=3}
	if ((i > 11) && (i < 15)) { y=4}
	
		for j=0, 99 {
	 Gauz1 = rdmc2gc1.repick()
print Gauz1
	if (i*33+17+Gauz1 > 499) {
	 npost1 = i*33+17+Gauz1-500
	} else {npost1 =i*33+17+Gauz1}
print npost1
	dbr = rdsyna.repick()
	if ((is_connected(GranuleCell[npost1], MossyCell[i]) == 0) && (vmc2gc.x[npost1] < 7))  {
	nc_append(i+ngcell+nbcell, npost1, dbr+2, 0.3e-3, 3, 10)  // Gcell[3] to Bcell[1]
	vmc2gc.x[npost1] +=1
	print i, npost1, dbr+2
	} else {j -= 1	print "MC2GC1"}
	}
		for j=0, 99 {
	 Gauz2 = rdmc2gc2.repick()
//print Gauz2
	if (i*33+17+Gauz2 < 0) {
	 npost2 =i*33+17+Gauz2+500
	} else {npost2 =i*33+17+Gauz2}
//print npost2
	dbr = rdsyna.repick()
	if ((is_connected(GranuleCell[npost2], MossyCell[i]) == 0) && (vmc2gc.x[npost2] < 7))  {
	nc_append(i+ngcell+nbcell, npost2, dbr+2, 0.3e-3, 3, 10)  // Gcell[3] to Bcell[1]
	vmc2gc.x[npost2] +=1
	print i, npost2, dbr+2
	} else {j -= 1	print "MC2GC2"}
	}

	for j=0, 0 {
	 Gauz3 = rdmc2bc.repick()
	if (y+Gauz3 > 5) {npost = y+Gauz3-6}
	if (y+Gauz3 < 0) {npost = y+Gauz3+6} 
	if ((y+Gauz3 > -1) && (y+Gauz3 < 6)) {npost = y+Gauz3}
	dbr = rdsyna.repick()
	if ((is_connected(BasketCell[npost], MossyCell[i]) == 0) && (vmc2bc.x[npost] < 4) && (Gauz3 !=0)) {
	nc_append(i+ngcell+nbcell, ngcell+npost, dbr+6, 0.3e-3, 3, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr+6
	vmc2bc.x[npost] += 1
	} else {j -= 1	print "mc2bc"}
	}

	for j=0, 2 {
	 Gauz3 = rdmc2mc1.repick()
//print Gauz3
	if (i+Gauz3 > 14) {npost = i+Gauz3-15 }
	if (i+Gauz3 < 0) {npost = i+Gauz3+15} 
	if ((i+Gauz3 >-1) && (i+Gauz3 < 15)) {npost = i+Gauz3}
//print npost
	dbr = rdsynb.repick()
	if ((is_connected(MossyCell[npost], MossyCell[i]) == 0) && (vmc2mc.x[npost] < 4) && (Gauz3 != 0))  {
	nc_append(i+ngcell+nbcell, npost+ngcell+nbcell, dbr+8, 0.5e-3, 2, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr+8
	vmc2mc.x[npost] +=1
	} else {	j -= 1	print "mc2mc"}
	}

	for j=0, 1 {
	 Gauz3 = rdmc2hc.repick()
	if (y+Gauz3 > 5) {npost = y+Gauz3-6}
	if (y+Gauz3 < 0) {npost = y+Gauz3+6} 
	if ((y+Gauz3 > -1) && (y+Gauz3 < 6)) {npost = y+Gauz3}
	dbr = rdsynb.repick()
	if ((is_connected(HIPPCell[npost], MossyCell[i]) == 0) && (vmc2hc.x[npost] < 6) && (Gauz3 != 0))  {
	nc_append(i+ngcell+nbcell, ngcell+nbcell+nmcell+npost, dbr+4, 0.2e-3, 3, 10)  // Gcell[3] to Bcell[1]
	print npost, dbr+4
	vmc2hc.x[npost] +=1
	} else {	j -= 1	print y, Gauz3, "mc2hc"}
	}


}
//******************************************************************************************
//**************HIPP Cell post synaptic connections ******************************



// for  i=0, nhcell-1 {
	
//		for j=0, 159 {
//	 npost = rdhc2gc.repick()
//	dbr = rdsyna.repick()
//	if ((is_connected(GranuleCell[npost], HIPPCell[i]) == 0) && (vhc2gc.x[npost] < 3))  {
//	nc_append(i+ngcell+nbcell+nmcell, npost, dbr+4, 0.5e-3, 1.6, 10)  // Gcell[3] to Bcell[1]
//	vhc2gc.x[npost] +=1
//	print i, npost, dbr+4
//	} else {j -= 1	print "HC2GC"}
//	}

//	for j=0, 3 {
//	 npost = rdhc2bc.repick()
//	dbr = rdsyna.repick()
//	if ((is_connected(BasketCell[npost-ngcell], HIPPCell[i]) == 0) && (vhc2bc.x[npost-ngcell] < 5))  {
//	nc_append(i+ngcell+nbcell+nmcell, npost, dbr+10, 0.5e-3, 1.6, 10)  // Gcell[3] to Bcell[1]
//	print npost, dbr+10
//	vhc2bc.x[npost-ngcell] += 1
//	} else {j -= 1	print "hc2bc"}
//	}

//	for j=0, 3 {
//	 npost = rdhc2mc.repick()
//	dbr = rdsynb.repick()
//	if ((is_connected(MossyCell[npost-ngcell-nbcell], HIPPCell[i]) == 0) && (vhc2mc.x[npost-ngcell-nbcell] < 2))  {
//	nc_append(i+ngcell+nbcell+nmcell, npost, dbr+13, 1.5e-3, 1, 10)  // Gcell[3] to Bcell[1]
//	print npost, dbr+13
//	vhc2mc.x[npost-ngcell-nbcell] += 1
//	} else {	j -= 1	print "hc2mc"}
//	}

//}
}
//*********************************Print out Net cons*********************************************************
strdef strvar
objref dfile
dfile = new File()

proc saveNet(){ local i
	dfile.wopen("N2I10sp")
	dfile.printf("Precell \tpstcell \t Synapse \n")
	for i=0, nclist.count-1 {
	dfile.printf("%s\t%s\t%s\n", nclist.object[i].precell, nclist.object[i].postcell, nclist.object[i].syn)}

dfile.printf("TO BC\n GC \tBC \tMC \tHC \n")
for i= 0, nbcell-1 {dfile.printf("%d\t%d\t%d\t%d \n",  vgc2bc.x[i], vbc2bc.x[i], vmc2bc.x[i], vhc2bc.x[i])}
dfile.printf("TO MC\n GC \tBC \tMC \tHC \n")
for i= 0, nmcell-1 {dfile.printf("%d\t%d\t%d\t%d\n",  vgc2mc.x[i], vbc2mc.x[i], vmc2mc.x[i], vhc2mc.x[i])}
dfile.printf("TO HC \n GC\t MC\n")
for i= 0, nhcell-1 {dfile.printf("%d\t%d\n", vgc2hc.x[i], vmc2hc.x[i])}
dfile.printf("TO GC\n BC\t MC\t HC\t GC\n")
for i= 0, ngcell-1 {dfile.printf("%d\t%d\t%d\t%d\n", vbc2gc.x[i], vmc2gc.x[i], vhc2gc.x[i], vgc2gc.x[i])}
dfile.close()

}


//******************************************************************************************
strdef strmat
objref efile
efile = new File()

	efile.wopen("M2I10sp.txt")
	efile.printf("t\t")
	for i = 0, 49 {
	b = i*10
	efile.printf("%s\t", cells.object[b])}
	for i = 498, cells.count-2{
	efile.printf("%s\t", cells.object[i])}
	efile.printf("\n")
	efile.close("M2I10sp.txt")

proc sMatrix(){ local  j

	efile.aopen("M2I10sp.txt")
	efile.printf("%f\t", t)
	for i = 0, 49 {
	b = i*10
	efile.printf("%f\t", cells.object[b].soma.v(0.5))}
	for j =498, cells.count-2 {
	efile.printf("%f\t", cells.object[j].soma.v(0.5))}
	efile.printf("\n")
	efile.close("M2I10sp.txt")
}

objref  VmT
objref VmMat[cells.count-1]
VmT = new Vector()
for i=0, cells.count-2 {
	VmMat[i] = new Vector()
	}

proc VecMx() { local i
	VmT.append(t)
	for i=0, cells.count-2 {
		VmMat[i].append( cells.object[i].soma.v(0.5))
		}
	}
	
objref Spike[cells.count-1]
for i=0, cells.count-2 {
	Spike[i] = new Vector()
	}
strdef Spkstr
objref dfile
dfile = new File()


proc SpkMx() { local i, j
	for i=0, cells.count-2 {
		Spike[i].spikebin(VmMat[i], 0)
		}

	dfile.wopen("S2I10sp.txt")

	while(k <  VmT.size) {
	for j = 0, cells.count-2 {
	if(Spike[j].x[k] != 0) {
	dfile.printf("%f\t%d\n", VmT.x[k], j)}
	}
	k +=1 }
	dfile.close("S2I10sp.txt")
	}


objref r_plt
proc initrPlt() {
	r_plt = new Graph(0)
	r_plt.size(0, tstop,0, cells.count)
	r_plt.label(0.95, 0.02, "ms")
	r_plt.label(0.01, 0.82, "neu")
	r_plt.view(0,0, tstop, cells.count,320,20,300,230)
}
 initrPlt()

proc plotAP() { local i, a
	a=1
 	r_plt.erase()
	while(j < cells.count-2) {
	for i = 0, VmT.size-1 {
	if ((j > ngcell-1)&&(j < ngcell+nbcell-1)) { a=2}
	if ((j > ngcell+nbcell-1)&&(j < ngcell+nbcell+nmcell-1)) { a=3}
	if (j > ngcell+nbcell+nmcell-1) { a=4}
	if (Spike[j].x[i] == 1) {
	r_plt.mark(VmT.x[i], j, "T", 5, a, 1)}}
	j+=1}
	r_plt.flush()
	}


//################################################################################################
proc init() { local dtsav, temp, secsav
finitialize(v_init)
t = -1000
dtsav = dt
secondorder =0
dt= 10
	// if cvode is on, turn it off to do large fixed step
temp= cvode.active()
if (temp!=0) {cvode.active(0)}
while(t<-100) { fadvance() print t}
	//restore cvode if reqd
if (temp!=0) {cvode.active(1)}
dt = dtsav
secondorder =2
t = 0
if (cvode.active()){
cvode.re_init()
}else{
fcurrent()
}
//frecord_init()
}
proc continuerun() {local rt
	eventcount =0
	eventslow =1
	stoprun =0
	if (using_cvode_) {
	cvode.event($1)
	}
	while(t < $1 && stoprun == 0) {
	step()
	sMatrix()
	VecMx()
	rt = stopsw()
	if (rt > realtime) {
		realtime = rt
		if (!stdrun_quiet) fastflushPlot()
		doNotify()
		if (realtime == 2 && eventcount > 50) {
			eventslow = int(eventcount/50)+1
		}
		eventcount = 0
	}else{
		eventcount = eventcount +1
		if ((eventcount%eventslow) == 0) {
			doEvents()
		}
	}
	}
	flushPlot()
}

objectvar save_window_, rvp_
objectvar scene_vector_[4]
objectvar ocbox_, ocbox_list_, scene_, scene_list_
{ocbox_list_ = new List()  scene_list_ = new List()}

{
xpanel("RunControl", 0)
v_init = -60
xvalue("Init","v_init", 1,"stdinit()", 1, 1 )
xbutton("Init & Run","run()")
xbutton("Stop","stoprun=1")
runStopAt = 5
xvalue("Continue til","runStopAt", 1,"{continuerun(runStopAt) stoprun=1}", 1, 1 )
runStopIn = 1
xvalue("Continue for","runStopIn", 1,"{continuerun(t + runStopIn) stoprun=1}", 1, 1 )
xbutton("Single Step","steprun()")
t = 0
xvalue("t","t", 2 )
tstop = 300	//1500
xvalue("Tstop","tstop", 1,"tstop_changed()", 0, 1 )
dt = 0.1
xvalue("dt","dt", 1,"setdt()", 0, 1 )
steps_per_ms = 10	//40
xvalue("Points plotted/ms","steps_per_ms", 1,"setdt()", 0, 1 )
xpanel(544,121)
}
{
save_window_ = new Graph(0)
save_window_.size(0,tstop,-80,40)
scene_vector_[2] = save_window_
{save_window_.view(0, -80, tstop, 120, 290, 470, 579.84, 208)}
graphList[0].append(save_window_)
save_window_.save_name("graphList[0].")
save_window_.addexpr("Gcell[0].soma.v(0.5)",1,1)
save_window_.addexpr("Bcell[0].soma.v(0.5)",2,1)
//save_window_.addexpr("Bcell[1].soma.v(0.5)",5,1)
save_window_.addexpr("Mcell[0].soma.v(0.5)",3,1)
save_window_.addexpr("Hcell[0].soma.v(0.5)",4,1)
//save_window_.addexpr("NetStim[0].interval",6,1)
//save_window_.addexpr("NetStim[0].y",7,1)
}
//{
//save_window_ = new Graph(0)
//save_window_.size(0,1500,0,0.029)
//scene_vector_[3] = save_window_
//{save_window_.view(0, 0, 1500, 0.029, 76, 213, 947.52, 385.6)}
//graphList[0].append(save_window_)
//save_window_.save_name("graphList[0].")
//save_window_.addexpr("Gcell[0].soma.cai_ccanl*1e2",1,1)
//save_window_.addexpr("Gcell[0].soma.isk_gskch*1e2",5,1)
//save_window_.addexpr("Gcell[0].soma.ik_borgka*1e2",2,1)
//save_window_.addexpr("Gcell[0].soma.ikf_ichan2",4,1)
//save_window_.addexpr("Gcell[0].soma.ik_cagk*1e2",3,1)
//save_window_.addexpr("Gcell[0].soma.inca_nca*1e2",4,1)
//save_window_.addexpr("Gcell[0].soma.ilca_lca*1e2",3,1)
//}

proc rrun(){
setuptime = startsw()
initNet()
setuptime = startsw() - setuptime
saveNet()
runtime = startsw()
run()
runtime = startsw() - runtime
SpkMx()
}

rrun()
plotAP()

objectvar scene_vector_[1]
{doNotify()}
//quit()
// the below allows modelview to run
access GranuleCell[0].soma

print "setuptime=", setuptime
print "runtime=", runtime

