/*
    Test precision spike detector by inserting 
    known spike train.
*/

M_ERROR setverbosity

0 << /tics_per_ms 14 dexp /resolution -4 dexp  >> SetStatus


-10 /min_exponent Set

0 /ms_per_tic get frexp

exch               
{0.5 eq} assert                  % base 2 tic size?
{1 sub min_exponent leq} assert  % sufficient resolution?

(XXXXsurvived resolution check) ==


% simulation parameters

[0 min_exponent -2] Range   /hlist Set
200.0                       /T     Set
/rate 0.1 def % spikes/ms
/delay 1.0 def %

% random spike train
rngdict /knuthlfg get 200 CreateRNG /rng Set
rng rdevdict /poisson get CreateRDV /poiss Set
poiss << /lambda rate T 20.0 sub mul >> SetStatus
poiss 1 RandomArray /n Set

% method 1: draw n random numbers uniformly distributed  
%           over the interval (0,T].
%
%n { pop rng drand 1.0 exch sub T 20.0 sub mul} Table Sort /s_in Set 

%            -14 works
n [ 1.0  2.125 ] /s_in Set %-15 dexp add] /s_in Set

% simulation function
/RecordSpikes
{
  dexp /h Set

  ResetKernel

  [0] << 
      /local_num_threads 1   
      /resolution h
      /rng_seeds [200]
  >> SetStatus

  /spike_generator Create /sg Set
  sg <<
      /origin        0.0       % in ms
      /start         0.0       % in ms
      /precise_times false
      /spike_times s_in
  >> SetStatus

  /spike_detector Create /sd Set
  sd <<
      /withtime true
      /withgid false
      /withpath false
      /precise_times true
      /record_to [/memory]
  >> SetStatus

  sg sd Connect

  T Simulate

} def 

hlist
{
    /i Set
    i dexp /h Set
    i RecordSpikes
    sd [/events /times] get cva
    /s_out Set
    cout i <- (: ) <- s_in s_out eq <- (  ) <- s_in s_out sub <-- endl ;        
} forall
