/*
 *  test_spike_generator.sli
 *
 *  This file is part of NEST
 *
 *  Copyright (C) 2004 by
 *  The NEST Initiative
 *
 *  See the file AUTHORS for details.
 *
 *  Permission is granted to compile and modify
 *  this file for non-commercial use.
 *  See the file LICENSE for details.
 *
 */


/* BeginDocumentation
   Name: testsuite::test_spike_generator - sli script to test spike_generator device

   Synopsis: (test_spike_generator) run

   Description:
   test_spike_generator checks the spike_generator device and its
   consistency with the nest simulation kernel.

   /start specifies the earliest possible time stamp of a spike event to
   be emitted. /stop specifies the earliest time stamp of a potential
   spike event that is not emitted.
 
   spike_generator is a device emitting spike events restricted to the
   time grid spanned by the computation step size h. Nevertheless, the
   time stamps of the spike events to be emitted are specified by device
   property /spike_times as double floats in milliseconds (ms). The
   spike_generator automatically assigns the appropriate time stamps on
   the simulation grid. For an arbitrary spike time s this is t=i*h with
   s in the interval (t-h, t], the corresponding event with time stamp t
   is emitted in the simulation step t-h -> t. See test_iaf_i0_refractory
   for consistency with spike generation in integrate-and-fire type neuron
   models and test_iaf_dc_aligned_stop.sli for consistency with the
   generation of grid based dc currents.

   A a consequence of the restriction of spike events to the simulation
   grid, multiple spike events with identical time stamps may be emitted.

   The results at different computation step sizes (resolutions) require
   some further discussion. Let us assume that /start and /stop are at
   joined grid positions of all resolutions tested. If all spike events
   are specified on joined grid positions, the simulation results are
   inependent of the computation step size.  However, if spikes occur on
   non-joined grid positions, spike times are shifted to the appropriate
   position on the current grid and simulation results will differ. Also,
   the spike count cannot be preserved because spikes at the end of the
   interval may be shifted to grid position /stop which is not a valid
   time stamp of a spike event anymore.

   Note that the number of emitted spike events can always be made 
   independent of the computation step size by setting /stop to an
   appropriately late joined grid position.

   The usage of values for /start and /stop that are not simultaneous
   grid positions of the computation step sizes to be used should be
   avoided because the set of spike events delivered in the simulation
   will vary in complex ways.

   The expected output is documented at the end of the script.

   FirstVersion: July 2004
   Author: Diesmann
   SeeAlso: spike_generator, testsuite::test_iaf_i0_refractory, testsuite::test_iaf_dc_aligned_stop
 */

/unittest (8331) require
/unittest using



% check, if truncating spike times to grid causes an assertion
% if precise_times is set to false
{
  ResetKernel
  [0] << 
      /local_num_threads 1
      /resolution 0.1
  >> SetStatus
      
  /spike_generator Create /sg Set
  sg <<
        /precise_times false
        /spike_times [4.33]   % in ms
        /origin 0.0           % in ms
        /start 0.0            % in ms  
        /stop  6.0            % in ms, 
  >> SetStatus
  10.0 Simulate
}
fail_or_die

% check, if spike times are rounded up or down,
% if doube value is closer than tic/2 to next grid point
% tic = 1 mu s
%
{
  ResetKernel
  [0] << 
      /local_num_threads 1
      /resolution 0.1
  >> SetStatus
      
  /spike_generator Create /sg Set
  sg <<
        /precise_times false
        /spike_times [2.9999 4.3001]   % in ms
        /origin 0.0                    % in ms
        /start 0.0                     % in ms  
        /stop  6.0                     % in ms
  >> SetStatus
  
  /spike_detector Create /sd Set
  sd << /withtime true /to_memory true /withgid true /time_in_steps true >> SetStatus
  sg sd 1.0 1.0 Connect

  10.0 Simulate
  
  sd [ /events /times ] get cva
  [30 43]
  eq
}
assert_or_die


%
% check, if precise times are conveyed up to desired precision
% check, if events outside [start, stop] are skipped
/AlignedEmission
{
  /expected Set
  /h Set

  ResetKernel

  [0] << 
         /local_num_threads 1
         /resolution h
	 /off_grid_spiking true
      >> SetStatus
      
  /spike_generator Create /sg Set
  sg <<
	/precise_times true
        /spike_times [0.1 5.0 5.3 5.300001 5.399999 5.9 6.0 9.3]   % in ms
        /origin 0.0                                                % in ms
        /start 5.0                                                 % in ms  
        /stop 6.0                                                  % in ms, set to 6.0 to keep number of emitted spikes constant
     >> SetStatus

  /spike_detector Create /sd Set
  sd << /withtime true /to_memory true /withgid true /time_in_steps false >> SetStatus

  sg sd 1.0 1.0 Connect

  7.0 Simulate

  sd [ /events /times ] get cva
  expected
  eq

} def


{
 Transpose
 {
  dup First exch Rest
  AlignedEmission
 } Map
 true exch {and} Fold   % all equal ?
} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%
% Expected output of this program:
%     
[
% h =  
  [ 0.1     0.2     0.5     1.0 ]
  %        time stamp
% [5.0      5.0      5.0      5.0]%  <-- would be here with /start 4.0
  [5.3      5.3      5.3      5.3]
  [5.300001 5.300001 5.300001 5.300001]
  [5.399999 5.399999 5.399999 5.399999]
  [5.9      5.9      5.9      5.9]
  [6.0      6.0      6.0      6.0]% <-- with /stop 6.0 this spike is still emitted
]%           


exch exec assert_or_die
